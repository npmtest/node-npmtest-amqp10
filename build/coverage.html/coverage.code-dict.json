{"/home/travis/build/npmtest/node-npmtest-amqp10/test.js":"/* istanbul instrument in package npmtest_amqp10 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-amqp10/lib.npmtest_amqp10.js":"/* istanbul instrument in package npmtest_amqp10 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_amqp10 = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_amqp10 = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-amqp10/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-amqp10 && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_amqp10 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_amqp10\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_amqp10.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_amqp10.rollup.js'] =\n            local.assetsDict['/assets.npmtest_amqp10.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_amqp10.__dirname + '/lib.npmtest_amqp10.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/index.js":"'use strict';\nvar Policy = require('./policies/policy'),\n    Client = require('./amqp_client'),\n    pu = require('./policies/policy_utilities'),\n    types = require('./types');\n\nmodule.exports = {\n  Client: Client,\n  Constants: require('./constants'),\n  Errors: require('./errors'),\n  Type: types.Type,\n\n  /**\n   * Policies encode many of the optional behaviors and settings of AMQP into a\n   * cohesive place that could potentially be standardized, could be loaded from\n   * JSON, etc.\n   */\n  Policy: {\n    PolicyBase: Policy,\n    Default: new Policy(),\n    EventHub: require('./policies/event_hub_policy'),\n    ServiceBusQueue: require('./policies/service_bus_queue_policy'),\n    ServiceBusTopic: require('./policies/service_bus_topic_policy'),\n    QpidJava: require('./policies/qpid_java_policy'),\n    ActiveMQ: require('./policies/activemq_policy'),\n    Utils: pu,\n    merge: function(overrides, base) { return pu.Merge(overrides, base || new Policy()); }\n  },\n\n  TransportProvider: require('./transport'),\n  AbstractTransport: require('./transport/abstract_transport'),\n  DescribedType: require('./types/described_type'),\n\n  /**\n   * translator, which allows you to translate from node-amqp-encoder'd\n   * values into the internal types used in this library. (e.g.\n   * [ 'symbol', 'symval' ] => Symbol('symval') ).\n   */\n  translator: require('./adapters/translate_encoder'),\n\n  /**\n   * Syntactic sugar for pluggable amqp10 Client behaviors\n   */\n  use: function(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new Error('Plugin is not a function');\n    }\n\n    plugin(Client);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/policy.js":"'use strict';\nvar url = require('url'),\n    constants = require('../constants'),\n    putils = require('./policy_utilities'),\n    u = require('../utilities');\n\nfunction containerName() {\n  return function() { return 'conn' + Date.now(); };\n}\n\nfunction linkName(prefix) {\n  var id = 1;\n  var pre = prefix;\n  return function() {\n    return pre + (id++);\n  };\n}\n\n/**\n * The default policy for amqp10 clients\n *\n * @class\n * @param {object} overrides    override values for the default policy\n */\nfunction Policy(overrides) {\n  if (!(this instanceof Policy))\n    return new Policy(overrides);\n\n  u.defaults(this, overrides, {\n    /**\n     * support subjects in link names with the following characteristics:\n     * receiver: \"amq.topic/news\", means a filter on the ReceiverLink will be made\n     *           for messages send with a subject \"news\"\n     *\n     * sender: \"amq.topic/news\", will automatically set \"news\" as the subject for\n     *         messages sent on this link, unless the user explicitly overrides\n     *         the subject.\n     *\n     * @name Policy#defaultSubjects\n     * @property {boolean}\n     */\n    defaultSubjects: true,\n\n    /**\n     * Options related to the reconnect behavior of the client. If this value is `null` reconnect\n     * is effectively disabled\n     *\n     * @name Policy#reconnect\n     * @type {Object|null}\n     * @property {number|null} [retries] How many times to attempt reconnection\n     * @property {string} [strategy='fibonacci'] The algorithm used for backoff. Can be `fibonacci` or `exponential`\n     * @property {boolean} [forever] Whether or not to attempt reconnection forever\n     */\n    reconnect: {\n      retries: 10,\n      strategy: 'fibonacci', // || 'exponential'\n      forever: true\n    },\n\n    /**\n     * @name Policy#connect\n     * @type {object}\n     * @property {object} options Options passed into the open performative on initial connection\n     * @property {string|function} options.containerId The id of the source container\n     * @property {string} options.hostname The name of the target host\n     * @property {number} options.maxFrameSize The largest frame size that the sending peer is able to accept on this connection\n     * @property {number} options.channelMax The channel-max value is the highest channel number that can be used on the connection\n     * @property {number} options.idleTimeout The idle timeout required by the sender\n     * @property {array<string>|null} options.outgoingLocales A list of the locales that the peer supports for sending informational text\n     * @property {array<string>|null} options.incomingLocales A list of locales that the sending peer permits for incoming informational text\n     * @property {array<string>|null} options.offeredCapabilities A list of extension capabilities the peer may use if the sender offers them\n     * @property {array|null} options.desiredCapabilities The desired-capability list defines which extension capabilities the sender may use if the receiver offers them\n     * @property {object|null} options.properties The properties map contains a set of fields intended to indicate information about the connection and its container\n     * @property {object} sslOptions Options used to initiate a TLS/SSL connection, with the exception of the following options all options in this object are passed directly to node's [tls.connect](https://nodejs.org/api/tls.html#tls_tls_connect_options_callback) method.\n     * @property {string|null} sslOptions.keyFile Path to the file containing the private key for the client\n     * @property {string|null} sslOptions.certFile Path to the file containing the certificate key for the client\n     * @property {string|null} sslOptions.caFile Path to the file containing the trusted cert for the client\n     * @property {boolean} sslOptions.rejectUnauthorized\n     * @property {string|null} saslMechanism Allows the sasl mechanism to be overriden by policy\n     */\n    connect: {\n      options: {\n        containerId: containerName(),\n        hostname: 'localhost',\n        maxFrameSize: constants.defaultMaxFrameSize,\n        channelMax: constants.defaultChannelMax,\n        idleTimeout: constants.defaultIdleTimeout,\n        outgoingLocales: constants.defaultOutgoingLocales,\n        incomingLocales: constants.defaultIncomingLocales,\n        offeredCapabilities: null,\n        desiredCapabilities: null,\n        properties: {},\n      },\n      sslOptions: {\n        keyFile: null,\n        certFile: null,\n        caFile: null,\n        rejectUnauthorized: false\n      },\n      saslMechanism: null\n    },\n\n    /**\n     * @name Policy#session\n     * @type {object}\n     * @property {object} options Options passed into the `begin` performative on session start\n     * @property {number} options.nextOutgoingId The transfer-id to assign to the next transfer frame\n     * @property {number} options.incomingWindow The maximum number of incoming transfer frames that the endpoint can currently receive\n     * @property {number} options.outgoingWindow The maximum number of outgoing transfer frames that the endpoint can currently send\n     * @property {function} window A function used to calculate how/when the flow control window should change\n     * @property {number} windowQuantum Quantum used in predefined window policies\n     * @property {boolean} enableSessionFlowControl Whether or not session flow control should be performed at all\n     */\n    session: {\n      options: {\n        nextOutgoingId: constants.session.defaultOutgoingId,\n        incomingWindow: constants.session.defaultIncomingWindow,\n        outgoingWindow: constants.session.defaultOutgoingWindow\n      },\n\n      window: putils.WindowPolicies.RefreshAtHalf,\n      windowQuantum: constants.session.defaultIncomingWindow,\n      enableSessionFlowControl: true\n    },\n\n    /**\n     * @name Policy#senderLink\n     * @type {object}\n     * @property {object} attach Options passed into the `attach` performative on link attachment\n     * @property {string|function} attach.name This name uniquely identifies the link from the container of the source to the container of the target node\n     * @property {string|boolean} attach.role The role being played by the peer\n     * @property {string|number} attach.sndSettleMode The delivery settlement policy for the sender\n     * @property {number} attach.maxMessageSize The maximum message size supported by the link endpoint\n     * @property {number} attach.initialDeliveryCount This must not be null if role is sender, and it is ignored if the role is receiver.\n     * @property {string} callback Determines when a send should call its callback ('settle', 'sent', 'none')\n     * @property {function|null} encoder=null The optional encoder used for all outgoing sends\n     * @property {boolean|null} reattach=null Whether the link should attempt reattach on detach\n     */\n    senderLink: {\n      attach: {\n        name: linkName('sender'),\n        role: constants.linkRole.sender,\n        sndSettleMode: constants.senderSettleMode.mixed,\n        maxMessageSize: 0,\n        initialDeliveryCount: 1\n      },\n\n      callback: putils.SenderCallbackPolicies.OnSettle,\n      encoder: null,\n      reattach: null\n    },\n\n    /**\n     * @name Policy#receiverLink\n     * @type {object}\n     * @property {object} attach Options passed into the `attach` performative on link attachment\n     * @property {string|function} attach.name This name uniquely identifies the link from the container of the source to the container of the target node\n     * @property {boolean} attach.role The role being played by the peer\n     * @property {number|string} attach.rcvSettleMode The delivery settlement policy for the receiver\n     * @property {number} attach.maxMessageSize The maximum message size supported by the link endpoint\n     * @property {number} attach.initialDeliveryCount This must not be null if role is sender, and it is ignored if the role is receiver.\n     * @property {function} credit A function that determines when (if ever) to refresh the receiver link's credit\n     * @property {number} creditQuantum Quantum used in pre-defined credit policy functions\n     * @property {function|null} decoder=null The optional decoder used for all incoming data\n     * @property {boolean|null} reattach=null Whether the link should attempt reattach on detach\n     */\n    receiverLink: {\n      attach: {\n        name: linkName('receiver'),\n        role: constants.linkRole.receiver,\n        rcvSettleMode: constants.receiverSettleMode.autoSettle,\n        maxMessageSize: 10000, // Arbitrary choice\n        initialDeliveryCount: 1\n      },\n      credit: putils.CreditPolicies.RefreshAtHalf,\n      creditQuantum: 100,\n      decoder: null,\n      reattach: null\n    },\n  });\n\n  putils.fixDeprecatedOptions(this);\n  return this;\n}\n\n\n/**\n * Parses a link address used for creating Sender and Receiver links.\n *\n * The resulting object has a required `name` property (used as the source\n * address in the attach performative), as well as an optional `subject` property\n * which (if specified) will automatically create a source filter.\n *\n * @inner @memberof Policy\n * @param {string} address the address to parse\n * @return {object}\n */\nPolicy.prototype.parseLinkAddress = function(address) {\n  // @todo: this \"parsing\" should be far more rigorous\n  if (!this.defaultSubjects) {\n    return { name: address };\n  }\n\n  var parts = address.split('/');\n  var result = { name: parts.shift() };\n  if (parts.length) result.subject = parts.shift();\n  return result;\n};\n\n/**\n * Parses an address for use when connecting to an AMQP 1.0 broker\n *\n * @inner @memberof Policy\n * @param {string} address the address to parse\n * @return {object}\n */\nPolicy.prototype.parseAddress = function(address) {\n  var parsedAddress = url.parse(address);\n  var result = {\n    host: parsedAddress.hostname || parsedAddress.href,\n    path: (parsedAddress.path && parsedAddress.path !== address) ?\n      parsedAddress.path : '/',\n    protocol: parsedAddress.protocol ?\n      parsedAddress.protocol.slice(0, -1).toLowerCase() : 'amqp',\n    href: parsedAddress.href\n  };\n\n  if (!!parsedAddress.port) {\n    result.port = parseInt(parsedAddress.port);\n  } else {\n    switch (result.protocol.toLowerCase()) {\n      case 'amqp': result.port = constants.defaultPort; break;\n      case 'amqps': result.port = constants.defaultTlsPort; break;\n    }\n  }\n\n  result.rootUri = result.protocol + '://';\n  if (!!parsedAddress.auth) {\n    result.rootUri += parsedAddress.auth + '@';\n\n    var userPass = parsedAddress.auth.split(':', 2);\n    result.user = userPass[0];\n    result.pass = userPass[1] || null;\n  }\n\n  result.rootUri += result.host + ':' + result.port;\n  return result;\n};\n\nmodule.exports = Policy;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/constants.js":"'use strict';\n\nvar Builder = require('buffer-builder');\n\nfunction amqpify(arr) {\n  var b = new Builder();\n  b.appendString('AMQP');\n  arr.forEach(function (c) { b.appendUInt8(c); });\n\n  return b.get();\n}\n\nvar Constants = {\n  defaultPort: 5672,\n  defaultTlsPort: 5671,\n  minMaxFrameSize: 512,\n  defaultMaxFrameSize: 4294967295,\n  defaultChannelMax: 65535,\n  defaultIdleTimeout: 120000,\n  requiredLocale: 'en-US',\n  defaultOutgoingLocales: 'en-US',\n  defaultIncomingLocales: 'en-US',\n  defaultHandleMax: 4294967295,\n  amqpVersion: amqpify([0, 1, 0, 0]),\n  saslVersion: amqpify([3, 1, 0, 0]),\n  session: {\n    defaultIncomingWindow: 100,\n    defaultOutgoingWindow: 100,\n    defaultOutgoingId: 1\n  },\n  frameType: {\n    amqp: 0x0, sasl: 0x1\n  },\n  saslOutcomes: {\n    ok: 0,\n    auth: 1,\n    sys: 2,\n    sys_perm: 3,\n    sys_temp: 4,\n    0: 'OK',\n    1: 'Authentication failed due to issue with credentials',\n    2: 'Authentication failed due to a system error',\n    3: 'Authentication failed due to a permanent system error',\n    4: 'Authentication failed due to a transient system error'\n  },\n  linkRole: {\n    sender: false,\n    receiver: true\n  },\n  senderSettleMode: {\n    unsettled: 0,\n    settled: 1,\n    mixed: 2\n  },\n  receiverSettleMode: {\n    autoSettle: 0,\n    settleOnDisposition: 1\n  },\n  terminusDurability: {\n    none: 0,\n    configuration: 1,\n    unsettledState: 2\n  },\n  terminusExpiryPolicy: {\n    linkDetach: 'link-detach',\n    sessionEnd: 'session-end',\n    connectionClose: 'connection-close',\n    never: 'never'\n  },\n  distributionMode: {\n    move: 'move',\n    copy: 'copy'\n  }\n};\n\nmodule.exports = Constants;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/policy_utilities.js":"'use strict';\n\nvar debug = require('debug')('amqp10:policy:utils'),\n    constants = require('../constants'),\n    errors = require('../errors'),\n    u = require('../utilities');\n\nvar WindowPolicies = {\n  RefreshAtHalf: function(session) {\n    if (session._sessionParams.incomingWindow < (session.policy.windowQuantum / 2)) {\n      debug('Refreshing session window by ' + session.policy.windowQuantum + ': ' + session._sessionParams.incomingWindow + ' remaining.');\n      session.addWindow(session.policy.windowQuantum);\n    }\n  },\n  RefreshAtEmpty: function(session) {\n    if (session._sessionParams.incomingWindow <= 0) {\n      debug('Refreshing session window by ' + session.policy.windowQuantum + ': ' + session._sessionParams.incomingWindow + ' remaining.');\n      session.addWindow(session.policy.windowQuantum);\n    }\n  },\n  DoNotRefresh: function(session) {\n    // Do Nothing\n  }\n};\n\nmodule.exports.WindowPolicies = WindowPolicies;\n\nvar CreditPolicies = {\n  RefreshAtHalf: function(link) {\n    if (link.linkCredit < (link.policy.creditQuantum / 2)) {\n      debug('Refreshing link ' + link.name + ' credit by ' + link.policy.creditQuantum + ': ' + link.linkCredit + ' remaining.');\n      link.addCredits(link.policy.creditQuantum);\n    }\n  },\n  RefreshAtEmpty: function(link) {\n    if (link.linkCredit <= 0) {\n      debug('Refreshing link ' + link.name + ' credit by ' + link.policy.creditQuantum + ': ' + link.linkCredit + ' remaining.');\n      link.addCredits(link.policy.creditQuantum);\n    }\n  },\n  RefreshSettled: function (threshold) {\n    return function (link, options) {\n      if (link.policy.rcvSettleMode === constants.receiverSettleMode.autoSettle) {\n        throw new errors.InvalidStateError('Cannot specify RefreshSettled as link refresh policy when auto-settling messages.');\n      }\n      var creditQuantum = (!!options && options.initial) ? link.policy.creditQuantum : link.settledMessagesSinceLastCredit;\n      if (creditQuantum > 0 && link.linkCredit < threshold) {\n        debug('Refreshing link ' + link.name + ' credit by ' + creditQuantum + ': ' + link.linkCredit + ' remaining.');\n        link.addCredits(creditQuantum);\n      }\n    };\n  },\n  DoNotRefresh: function(link) {\n    // Do Nothing\n  }\n};\n\nmodule.exports.CreditPolicies = CreditPolicies;\n\n/**\n * Defines the behavior of the return value of `SenderLink.send`\n * @enum\n */\nvar SenderCallbackPolicy = {\n  /** Callback immediately after sending, no promise is created */\n  None: 'none',\n  /** Only callback when settled Disposition received from recipient */\n  OnSettle: 'settled',\n  /** Callback as soon as sent, will not call-back again if future disposition\n   *  results in error. */\n  OnSent: 'sent',\n};\n\nmodule.exports.SenderCallbackPolicies = SenderCallbackPolicy; // deprecated\nmodule.exports.SenderCallbackPolicy = SenderCallbackPolicy;\n\nfunction fixDeprecatedOptions(policy) {\n  if (policy === undefined || policy === null) return;\n\n  if (policy.senderLink &&\n      policy.senderLink.attach &&\n      policy.senderLink.attach.hasOwnProperty('senderSettleMode')) {\n    policy.senderLink.attach.sndSettleMode =\n      policy.senderLink.attach.senderSettleMode;\n    delete policy.senderLink.attach.senderSettleMode;\n  }\n\n  if (policy.receiverLink &&\n      policy.receiverLink.attach &&\n      policy.receiverLink.attach.hasOwnProperty('receiverSettleMode')) {\n    policy.receiverLink.attach.rcvSettleMode = policy.receiverLink.attach.receiverSettleMode;\n    delete policy.receiverLink.attach.receiverSettleMode;\n  }\n}\n\nmodule.exports.fixDeprecatedOptions = fixDeprecatedOptions;\n\nfunction merge(newPolicy, base) {\n  var policy = u.deepMerge(newPolicy, base);\n  fixDeprecatedOptions(policy);\n  return policy;\n}\n\nmodule.exports.Merge = merge;\n\n// Receiver links process messages N at a time, only renewing credits on ack.\nmodule.exports.RenewOnSettle = function(initialCredit, threshold, basePolicy) {\n  basePolicy = basePolicy || {};\n\n  return merge({\n    receiverLink: {\n      credit: CreditPolicies.RefreshSettled(threshold),\n      creditQuantum: initialCredit,\n      attach: {\n        rcvSettleMode: constants.receiverSettleMode.settleOnDisposition\n      }\n    }\n  }, basePolicy);\n};\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/errors.js":"'use strict';\n\nvar util = require('util'),\n    AMQPError = require('./types/amqp_error');\n\nvar errors = module.exports = {};\n\nerrors.wrapProtocolError = function(err) {\n  if (err instanceof AMQPError) {\n    return new errors.ProtocolError(err.condition, err.description, err.info);\n  }\n\n  return err;\n};\n\n/**\n * The base error all amqp10 Errors inherit from.\n *\n * @constructor\n * @alias Error\n */\nerrors.BaseError = function() {\n  var tmp = Error.apply(this, arguments);\n  tmp.name = this.name = 'AmqpError';\n\n  this.message = tmp.message;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, this.constructor);\n};\nutil.inherits(errors.BaseError, Error);\n\nerrors.ProtocolError = function(condition, description, errorInfo) {\n  errors.BaseError.call(this, condition + ':' + (description || 'no description'));\n  this.name = 'AmqpProtocolError';\n\n  this.condition = condition;\n  this.description = description;\n  this.errorInfo = errorInfo;\n};\nutil.inherits(errors.ProtocolError, errors.BaseError);\n\n/**\n * AMQP Header is malformed.\n *\n * @param header\n * @extends BaseError\n * @constructor\n */\nerrors.MalformedHeaderError = function(header) {\n  errors.BaseError.call(this, 'malformed header: ' + header);\n  this.name = 'AmqpMalformedHeaderError';\n};\nutil.inherits(errors.MalformedHeaderError, errors.BaseError);\n\n/**\n * Method or feature is not yet implemented.\n *\n * @param feature\n * @extends BaseError\n * @constructor\n */\nerrors.NotImplementedError = function(feature) {\n  errors.BaseError.call(this, feature + ' not yet implemented');\n  this.name = 'AmqpNotImplementedError';\n};\nutil.inherits(errors.NotImplementedError, errors.BaseError);\n\n/**\n * Payload is malformed or cannot be parsed.\n *\n * @param payload\n * @extends BaseError\n * @constructor\n */\nerrors.MalformedPayloadError = function(payload) {\n  errors.BaseError.call(this, 'malformed payload: ' + payload);\n  this.name = 'AmqpMalformedPayloadError';\n};\nutil.inherits(errors.MalformedPayloadError, errors.BaseError);\n\n/**\n * Given object cannot be encoded successfully.\n *\n * @param value         the value that caused the encoding error\n * @param message       an optional message giving context to the error\n * @extends BaseError\n * @constructor\n */\nerrors.EncodingError = function(value, message) {\n  message = message || 'encoding failure';\n  errors.BaseError.call(this, message);\n  this.name = 'AmqpEncodingError';\n  this.value = value;\n};\nutil.inherits(errors.EncodingError, errors.BaseError);\n\n/**\n * Violation of AMQP flow control.\n *\n * @param msg\n * @extends BaseError\n * @constructor\n */\nerrors.OverCapacityError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpOverCapacityError';\n};\nutil.inherits(errors.OverCapacityError, errors.BaseError);\n\n/**\n * Authentication failure.\n *\n * @param msg\n * @extends BaseError\n * @constructor\n */\nerrors.AuthenticationError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpAuthenticationError';\n};\nutil.inherits(errors.AuthenticationError, errors.BaseError);\n\n/**\n * Invalid state.\n *\n * @param msg\n * @extends BaseError\n * @constructor\n */\nerrors.InvalidStateError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpInvalidStateError';\n};\nutil.inherits(errors.InvalidStateError, errors.BaseError);\n\n/**\n * Connection error\n *\n * @param msg\n * @extends BaseError\n * @constructor\n */\nerrors.ConnectionError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpConnectionError';\n};\nutil.inherits(errors.ConnectionError, errors.BaseError);\n\n/**\n * Disconnected error\n *\n * @param msg\n * @extends ConnectionError\n * @constructor\n */\nerrors.DisconnectedError = function(msg) {\n  errors.ConnectionError.call(this, msg);\n  this.name = 'AmqpDisconnectedError';\n};\nutil.inherits(errors.DisconnectedError, errors.ConnectionError);\n\n/**\n * AMQP Version error\n *\n * @param msg\n * @extends BaseError\n * @constructor\n */\nerrors.VersionError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpVersionError';\n};\nutil.inherits(errors.VersionError, errors.BaseError);\n\n/**\n * Invalid subject specified for receiver or sender link creation.\n *\n * @param subject the subject specified\n * @extends BaseError\n * @constructor\n */\nerrors.InvalidSubjectError = function(subject) {\n  errors.BaseError.call(this, 'Invalid subject: ' + subject);\n  this.name = 'AmqpInvalidSubjectError';\n};\nutil.inherits(errors.InvalidSubjectError, errors.BaseError);\n\n/**\n * Used to signal transport-related errors\n *\n * @extends BaseError\n * @constructor\n */\nerrors.TransportError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpTransportError';\n};\nutil.inherits(errors.TransportError, errors.BaseError);\n\n/**\n * Used to indicate that a link requires an active connection\n *\n * @extends BaseError\n * @constructor\n */\nerrors.NotConnectedError = function(msg) {\n  errors.BaseError.call(this, msg);\n  this.name = 'AmqpNotConnectedError';\n};\nutil.inherits(errors.NotConnectedError, errors.BaseError);\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/amqp_error.js":"'use strict';\nvar ErrorCondition = require('./error_condition'),\n    defineComposite = require('./composite_type').defineComposite;\n\nfunction errorCondition(value) {\n  if (!ErrorCondition.hasOwnProperty(value)) {\n    return value;\n  }\n\n  return ErrorCondition.hasOwnProperty(ErrorCondition[value]) ?\n    ErrorCondition[ErrorCondition[value]] :\n    ErrorCondition[value];\n}\n\nvar AMQPError = defineComposite({\n  name: 'error', code: 0x1d,\n  fields: [\n    { name: 'condition', type: 'symbol', requires: errorCondition, mandatory: true },\n    { name: 'description', type: 'string' },\n    { name: 'info', type: 'fields', default: {} }\n  ]\n});\n\nmodule.exports = AMQPError;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/error_condition.js":"'use strict';\nvar u = require('../utilities'),\n    ErrorCondition = module.exports = {};\n\nfunction defineErrorCondition(symbol) {\n  var stringReference = symbol.replace(/amqp:/, '');\n  var enumReference = u.camelCase(stringReference);\n  enumReference = enumReference.charAt(0).toUpperCase() + enumReference.slice(1);\n  ErrorCondition[stringReference] = symbol;\n  ErrorCondition[enumReference] = stringReference;\n  ErrorCondition[symbol] = symbol;\n}\n\n// shared\ndefineErrorCondition('amqp:internal-error');\ndefineErrorCondition('amqp:not-found');\ndefineErrorCondition('amqp:unauthorized-access');\ndefineErrorCondition('amqp:decode-error');\ndefineErrorCondition('amqp:resource-limit-exceeded');\ndefineErrorCondition('amqp:not-allowed');\ndefineErrorCondition('amqp:invalid-field');\ndefineErrorCondition('amqp:not-implemented');\ndefineErrorCondition('amqp:resource-locked');\ndefineErrorCondition('amqp:precondition-failed');\ndefineErrorCondition('amqp:resource-deleted');\ndefineErrorCondition('amqp:illegal-state');\ndefineErrorCondition('amqp:frame-size-too-small');\n\n// connection\ndefineErrorCondition('amqp:connection:forced');\ndefineErrorCondition('amqp:connection:framing-error');\ndefineErrorCondition('amqp:connection:redirect');\n\n// session\ndefineErrorCondition('amqp:session:window-violation');\ndefineErrorCondition('amqp:session:errant-link');\ndefineErrorCondition('amqp:session:handle-in-use');\ndefineErrorCondition('amqp:session:unattached-handle');\n\n// link\ndefineErrorCondition('amqp:link:detach-forced');\ndefineErrorCondition('amqp:link:transfer-limit-exceeded');\ndefineErrorCondition('amqp:link:message-size-exceeded');\ndefineErrorCondition('amqp:link:redirect');\ndefineErrorCondition('amqp:link:stolen');\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/utilities.js":"'use strict';\nvar _ = require('lodash'),\n    //errors = require('./errors'),\n    crypto = require('crypto');\n\nvar utilities = module.exports = {};\n\n// lodash aliases\nutilities.defaults = _.defaultsDeep;\nutilities.includes = _.includes;\nutilities.isObject = _.isObject;\nutilities.isNumber = _.isNumber;\nutilities.values = _.values;\nutilities.merge = _.merge;\nutilities.clone = _.cloneDeep;\n\nfunction bufferEqualsLegacy(lhs, rhs, offset1, offset2, size) {\n  if (offset1 === undefined && offset2 === undefined && size === undefined) {\n    if (lhs.length !== rhs.length) return false;\n  }\n  var slice1 = (offset1 === undefined && size === undefined) ? lhs : lhs.slice(offset1 || 0, size || lhs.length);\n  var slice2 = (offset2 === undefined && size === undefined) ? rhs : rhs.slice(offset2 || 0, size || rhs.length);\n  for (var idx = 0; idx < slice1.length; ++idx) {\n    if (slice1[idx] !== slice2[idx]) return false;\n  }\n  return true;\n}\n\nfunction bufferEquals(lhs, rhs) {\n  return lhs.compare(rhs) === 0;\n}\n\nutilities.bufferEquals =\n  (typeof Buffer.compare === 'function') ? bufferEquals: bufferEqualsLegacy;\n\nfunction deepMerge() {\n  var args = Array.prototype.slice.call(arguments);\n  var helper = function(tgt, src, key) {\n    var s2, t2;\n    if (key === undefined) {\n      t2 = tgt;\n      s2 = src;\n    } else {\n      if (!tgt[key]) {\n        if (src[key] instanceof Buffer) {\n          tgt[key] = new Buffer(src[key]);\n        } else {\n          tgt[key] = new src[key].constructor();\n        }\n      }\n      t2 = tgt[key];\n      s2 = src[key];\n    }\n\n    for (var k2 in s2) {\n      if (s2.hasOwnProperty(k2)) {\n        var v2 = s2[k2];\n        if (v2 !== null && typeof v2 === 'object') {\n          helper(t2, s2, k2);\n        } else {\n          t2[k2] = s2[k2];\n        }\n      }\n    }\n  };\n\n  var merged = null;\n  for (var idx = args.length - 1; idx >= 0; --idx) {\n    var curObj = args[idx];\n    if (merged === null) {\n      merged = curObj.constructor();\n    }\n    helper(merged, curObj);\n  }\n  return merged;\n}\n\nutilities.deepMerge = deepMerge;\nutilities.deepCopy = deepMerge;\n\n/**\n * Convenience method to assert that a given options object contains the required arguments.\n *\n * @param options\n * @param argnames\n */\nfunction assertArguments(options, argnames) {\n  if (!argnames) return;\n  if (!options) throw new TypeError('missing arguments: ' + argnames);\n  argnames.forEach(function (argname) {\n    if (!options.hasOwnProperty(argname)) {\n      throw new TypeError('missing argument: ' + argname);\n    }\n  });\n}\n\nutilities.assertArguments = assertArguments;\n\nfunction assertArgument(arg, argname) {\n  if (arg === undefined) throw new TypeError('missing argument: ' + argname);\n}\n\nutilities.assertArgument = assertArgument;\n\nfunction range(start, end) {\n  var result = [], c = end - start + 1;\n  while(c--) result[c] = end--;\n  return result;\n}\n\nutilities.generateTimeouts = function(options) {\n  if (options.strategy === 'exponential')\n    return range(0, options.retries - 1)\n      .map(function(i) { return Math.pow(2, i) * 1000; });\n\n  // default to fibonacci\n  return range(0, options.retries - 1)\n    .reduce(function(result, value, idx) {\n      if (idx === 0) {\n        result.push(0);\n      } else if (idx === 1) {\n        result.push(1);\n      } else {\n        result.push((result[idx - 2] + result[idx - 1]));\n      }\n\n      return result;\n    }, [])\n    .map(function(i) { return i * 1000; });\n};\n\n/**\n * Calculates the start and end for a disposition frame\n *\n * @param message    either a single message or an array of them\n * @return {Object}\n */\nutilities.dispositionRange = function(message) {\n  var first, last;\n  if (_.isArray(message)) {\n    first = message[0]._deliveryId;\n    last = message[message.length - 1]._deliveryId;\n  } else {\n    first = last = message._deliveryId;\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n};\n\n/**\n * Generates a link name for a given address\n *\n * @param address             link address\n * @param [policyOverrides]   link creation policy overrides\n * @return {String}\n */\nutilities.linkName = function(address, policyOverrides) {\n  var name = ((!!policyOverrides && !!policyOverrides.name) ?\n    policyOverrides.name : address + '_' + uuidV4());\n  if (policyOverrides.hasOwnProperty('attach') &&\n      policyOverrides.attach.hasOwnProperty('source') &&\n      policyOverrides.attach.source.hasOwnProperty('dynamic') &&\n      policyOverrides.attach.source.dynamic === true) {\n    name = 'dynamic' + name;\n  }\n\n  return name;\n};\n\nutilities.camelCase = function(name) {\n  return name.toLowerCase()\n    .replace(/[-_:]+/g, ' ')\n    .replace(/[^\\w\\s]/g, '')\n    .replace(/ (.)/g, function($1) { return $1.toUpperCase(); })\n    .replace(/ /g, '' );\n};\n\n// Maps for number <-> hex string conversion\nvar BYTE_TO_HEX = [];\nvar HEX_TO_BYTE = {};\nfor (var i = 0; i < 256; i++) {\n  BYTE_TO_HEX[i] = (i + 0x100).toString(16).substr(1);\n  HEX_TO_BYTE[BYTE_TO_HEX[i]] = i;\n}\n\nfunction parseUuid(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = HEX_TO_BYTE[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\nfunction unparseUuid(buf, offset) {\n  var i = offset || 0;\n  return  BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] + '-' +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] + '-' +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] + '-' +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] + '-' +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]] +\n          BYTE_TO_HEX[buf[i++]] + BYTE_TO_HEX[buf[i++]];\n}\n\nfunction uuidV4() {\n  var data = crypto.randomBytes(16);\n  data[6] = (data[6] & 0x0f) | 0x40;\n  data[8] = (data[8] & 0x3f) | 0x80;\n  return unparseUuid(data);\n}\n\nutilities.parseUuid = parseUuid;\nutilities.unparseUuid = unparseUuid;\nutilities.uuidV4 = uuidV4;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/composite_type.js":"'use strict';\nvar util = require('util'),\n    DescribedType = require('./described_type'),\n    ForcedType = require('./forced_type');\n\nvar knownTypes = {};\nfunction convertKnownType(described) {\n  if (described === undefined || described === null ||\n      (!(described instanceof DescribedType))) {\n    return described;\n  }\n\n  if (knownTypes.hasOwnProperty(described.descriptor))\n    return new knownTypes[described.descriptor](described);\n  return undefined;\n}\n\nfunction wrapField(field, value) {\n  if (value instanceof ForcedType) return value;\n  if (value === undefined || value === null) {\n    if (field.mandatory) throw new Error('missing mandatory field: ' + field.name);\n    if (field.hasOwnProperty('default')) return wrapField(field, field.default);\n    return null;\n  }\n\n  // e.g. Connection containerId()\n  if (typeof value === 'function') value = value();\n\n  if (field.hasOwnProperty('requires')) {\n    if (value instanceof field.requires) return value;\n    if (field.hasOwnProperty('type') && field.type !== '*')\n      return new ForcedType(field.type, field.requires(value));\n    return new field.requires(value);\n  }\n\n  if (field.type === '*') return value;\n\n  if (Array.isArray(value)) {\n    if (field.multiple === false) {\n      throw Error('field ' + field.name + ' does not support multiple values, got ' + JSON.stringify(value));\n    }\n\n    if (value.length === 0) return new ForcedType(field.type, null);\n    else if (value.length === 1) return new ForcedType(field.type, value[0]);\n    else {\n      var values = [], _len = value.length;\n      for (var i = 0; i < _len; ++i) values.push(wrapField(field, value[i]));\n      return new ForcedType('list', values);\n    }\n  }\n\n  // @todo: this is a cheesy way to determine if its a composite type already\n  if (value.toDescribedType && typeof value.toDescribedType === 'function') return value;\n\n  return new ForcedType(field.type, value);\n}\n\nfunction compositeAccessors(index, field) {\n  return {\n    enumerable: true, configurable: false,\n    get: function() {\n      var value = (this.value[index] instanceof ForcedType) ? this.value[index].value : this.value[index];\n      if (value === undefined && field.hasOwnProperty('default')) return field.default;\n      return value;\n    },\n    set: function(value) { this.value[index] = wrapField(field, value); }\n  };\n}\n\nfunction defineComposite(Base, definition) {\n  if (definition === undefined) {\n    definition = Base;\n    Base = Object;\n  }\n\n  var Composite = function(fields) {\n    fields = fields || {};\n    Composite.super_.call(this, fields.channel);\t // @todo: this is AMQPFrame specific, get it out of here\n\n    this.value = [];\n    var _len = Composite.fields.length, i, field;\n    if (fields instanceof DescribedType) {\n      var values = fields.value ? fields.value.map(convertKnownType) : [];\n      for (i = 0; i < _len; ++i) {\n        field = Composite.fields[i];\n        this[field.name] = values[i];\n      }\n    } else {\n      for (i = 0; i < _len; ++i) {\n        field = Composite.fields[i];\n        if (fields && fields.hasOwnProperty(field.name)) {\n          this[field.name] = fields[field.name];\n        } else if (field.hasOwnProperty('default')) {\n          this[field.name] = wrapField(field, field.default);\n        } else {\n          this[field.name] = null;\n        }\n      }\n    }\n  };\n\n  Composite.fields = definition.fields;\n  Composite.descriptor = {\n    code: definition.code,\n    name: 'amqp:' + definition.name + ':list'\n  };\n\n  var properties = {};\n  for (var i = 0; i < definition.fields.length; i++) {\n    var field = definition.fields[i];\n    properties[field.name] = compositeAccessors(i, field);\n  }\n\n  Composite.super_ = Base;\n  Composite.prototype = Object.create(Base.prototype, properties);\n  Composite.prototype.toDescribedType = function() {\n    return new DescribedType(Composite.descriptor.code, new ForcedType('list', this.value));\n  };\n\n  Composite.prototype.inspect = function(depth) {\n    var result = '@' + definition.name + '(' + definition.code + ')';\n    var _len = definition.fields.length, values = [];\n    for (var i = 0; i < _len; ++i) {\n      var field = definition.fields[i];\n      values.push(field.name + '=' + util.inspect(this[field.name]));\n    }\n\n    result += ' [' + values.join(' ') + ']';\n    return result;\n  };\n\n  knownTypes[Composite.descriptor.name] = Composite;\n  knownTypes[Composite.descriptor.code] = Composite;\n  return Composite;\n}\n\nmodule.exports = {\n  defineComposite: defineComposite,\n  wrapField: wrapField\n};\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/described_type.js":"'use strict';\n\n/**\n * Described type, as described in the AMQP 1.0 spec as follows:\n *\n<pre>\n             constructor                       untyped bytes\n                  |                                 |\n      +-----------+-----------+   +-----------------+-----------------+\n      |                       |   |                                   |\n ...  0x00 0xA1 0x03 \"URL\" 0xA1   0x1E \"http://example.org/hello-world\"  ...\n           |             |  |     |                                   |\n           +------+------+  |     |                                   |\n                  |         |     |                                   |\n             descriptor     |     +------------------+----------------+\n                            |                        |\n                            |         string value encoded according\n                            |             to the str8-utf8 encoding\n                            |\n                 primitive format code\n               for the str8-utf8 encoding\n\n</pre>\n *\n * (Note: this example shows a string-typed descriptor, which should be considered reserved)\n *\n * @constructor\n * @param descriptorOrType  Descriptor for the type (can be any valid AMQP type, including another described type), or the type itself.\n * @param value             Value of the described type (can also be any valid AMQP type, including another described type).\n */\nfunction DescribedType(descriptorOrType, value) {\n  if (descriptorOrType && descriptorOrType.prototype && descriptorOrType.prototype.Descriptor)\n    this.descriptor = descriptorOrType.prototype.Descriptor.code;\n  else\n    this.descriptor = descriptorOrType;\n\n  this.value = value;\n}\n\nDescribedType.prototype.getValue = function() {\n  return this.value;\n};\n\nmodule.exports = DescribedType;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/forced_type.js":"'use strict';\nvar util = require('util');\n\n/**\n * ForcedType coerces the encoder to encode to the given type, regardless of what it might think.\n *\n * @param typeName          Symbolic name or specific code (e.g. 'long', or 0xA0)\n * @param value             Value to encode, should be compatible or bad things will occur\n * @constructor\n */\nfunction ForcedType(typeName, value) {\n  this.typeName = typeName;\n  this.value = value;\n}\n\nForcedType.prototype.inspect = function(depth) {\n  return util.inspect(this.value);\n};\n\nForcedType.prototype.valueOf = function() {\n  return this.value;\n};\n\nmodule.exports = ForcedType;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/amqp_client.js":"'use strict';\nvar EventEmitter = require('events').EventEmitter,\n    Promise = require('bluebird'),\n    debug = require('debug')('amqp10:client'),\n    util = require('util'),\n\n    Connection = require('./connection'),\n    Sasl = require('./sasl'),\n    Session = require('./session'),\n    ReceiverStream = require('./streams/receiver_stream'),\n    SenderStream = require('./streams/sender_stream'),\n\n    errors = require('./errors'),\n\n    translator = require('./adapters/translate_encoder'),\n    Policy = require('./policies/policy'),\n\n    pu = require('./policies/policy_utilities'),\n    u = require('./utilities');\n\n/**\n * AMQPClient is the top-level class for interacting with node-amqp10.  Instantiate this class, connect, and then send/receive\n * as needed and behind the scenes it will do the appropriate work to setup and teardown connections, sessions, and links and manage flow.\n * The code does its best to avoid exposing AMQP-specific types and attempts to convert them where possible, but on the off-chance you\n * need to speak AMQP-specific (e.g. to set a filter to a described-type), you can use node-amqp-encoder and the\n * translator adapter to convert it to our internal types.  See simple_eventhub_test.js for an example.\n *\n * Configuring AMQPClient is done through fa Policy class.  By default, DefaultPolicy will be used - it assumes AMQP defaults wherever\n * possible, and for values with no spec-defined defaults it tries to assume something reasonable (e.g. timeout, max message size).\n *\n * To define a new policy, you can merge your values into an existing one by calling AMQPClient.policies.merge(yourPolicy, existingPolicy).\n * This does a deep-merge, allowing you to only replace values you need.  For instance, if you wanted the default sender settle policy to be auto-settle instead of mixed,\n * you could just use\n *\n <pre>\n var AMQP = require('amqp10');\n var client = new AMQP.Client(AMQP.Policy.merge({\n   senderLink: {\n     attach: {\n       sndSettleMode: AMQP.Constants.senderSettleMode.settled\n     }\n   }\n });\n </pre>\n *\n * Obviously, setting some of these options requires some in-depth knowledge of AMQP, so I've tried to define specific policies where I can.\n * For instance, for Azure EventHub connections, you can use the pre-build EventHubPolicy.\n *\n * Also, within the policy, see the encoder and decoder defined in the send/receive policies.  These define what to do with the message\n * sent/received, and by default do a simple pass-through, leaving the encoding to/decoding from AMQP-specific types up to the library which\n * does a best-effort job.  See EventHubPolicy for a more complicated example, turning objects into UTF8-encoded buffers of JSON-strings.\n *\n * @class\n * @extends EventEmitter\n * @param {Policy}  [policy]           Policy to use for connection, sessions, links, etc.  Defaults to DefaultPolicy.\n * @param {Obeject} [policyOverrides]  Additional overrides for the provided policy\n * @fires AMQPClient#client:errorReceived\n * @fires AMQPClient#connection:opened\n * @fires AMQPClient#connection:closed\n */\nfunction AMQPClient(policy, policyOverrides) {\n  if (!(policy instanceof Policy)) {\n    this.policy = pu.Merge(policy, new Policy());\n  } else {\n    this.policy = policy || new Policy();\n    if (!!policyOverrides) this.policy = pu.Merge(policyOverrides, this.policy);\n  }\n\n  this._connection = null;\n  this._session = null;\n\n  this._reconnect = null;\n  if (!!this.policy.reconnect) {\n    this._timeouts = u.generateTimeouts(this.policy.reconnect);\n  }\n}\nutil.inherits(AMQPClient, EventEmitter);\n\n/**\n * Error received events\n *\n * @event AMQPClient#client:errorReceived\n * @type {object}\n * @property {object} the error received\n */\nAMQPClient.ErrorReceived = 'client:errorReceived'; // Called with error\n\n/**\n * Connection opened event.\n *\n * @event AMQPClient#connection:opened\n */\nAMQPClient.ConnectionOpened = 'connection:opened';\n\n/**\n * Connection closed event.\n *\n * @event AMQPClient#connection:closed\n */\nAMQPClient.ConnectionClosed = 'connection:closed';\n\n/**\n * Connects to a given AMQP server endpoint. Sets the default queue, so e.g.\n * amqp://my-activemq-host/my-queue-name would set the default queue to\n * my-queue-name for future send/receive calls.\n *\n * @inner @memberof AMQPClient\n * @param {string} url      URI to connect to - right now only supports <code>amqp|amqps</code> as protocol.\n * @param {object} [policyOverrides]      Policy overrides used for creating this connection\n *\n * @return {Promise}\n */\nAMQPClient.prototype.connect = function(url, policyOverrides) {\n  var self = this;\n  policyOverrides = policyOverrides || {};\n  var connectPolicy = u.deepMerge(policyOverrides, self.policy.connect);\n  return new Promise(function(resolve, reject) {\n    if (self._connection) {\n      self._connection.close();\n      self._clearConnectionState();\n    }\n\n    debug('connecting to: ' + url);\n    self._reconnect = self.connect.bind(self, url);\n    var address = self.policy.parseAddress(url);\n    self._defaultQueue = address.path.substr(1);\n    connectPolicy.options.hostname = address.host;\n    var saslMechanism = connectPolicy.saslMechanism;\n    var sasl = null;\n    if (saslMechanism) {\n      if (!u.includes(Sasl.Mechanism, saslMechanism)) {\n        throw new errors.NotImplementedError(\n          saslMechanism + ' is not a supported saslMechanism policy');\n      }\n      if (saslMechanism === Sasl.Mechanism.NONE) {\n        if (address.user) {\n          console.warn(\n              'Sasl disabled by policy, but credentials provided in endpoint URI');\n        }\n      } else if (saslMechanism === Sasl.Mechanism.PLAIN && !address.user) {\n        throw new errors.AuthenticationError(\n            'Sasl PLAIN requested, but no credentials provided in endpoint URI');\n      } else {\n        sasl = new Sasl(saslMechanism);\n      }\n    } else if (address.user) {\n      // force SASL plain if no mechanism specified, but creds in URI\n      connectPolicy.saslMechanism = Sasl.Mechanism.PLAIN;\n      sasl = new Sasl(Sasl.Mechanism.PLAIN);\n    }\n    if (!!sasl && !!address.vhost) {\n      sasl._remoteHostname = address.vhost;\n      connectPolicy.options.hostname = address.vhost;\n    }\n\n    self._connection = self._newConnection(connectPolicy);\n    self._connection.on(Connection.Connected, function(c) {\n      debug('connected');\n      self.emit(AMQPClient.ConnectionOpened);\n      if (self._session) {\n        debug('session already exists, re-using');\n        self._session.connection = self._connection;\n      } else {\n        self._session = self._newSession(c);\n      }\n\n      self._session.once(Session.Mapped, function(s) {\n        debug('mapped');\n        self.emit('connected');\n        resolve(self);\n      });\n\n      self._session.begin(self.policy.session);\n    });\n\n    self._connection.on(Connection.Disconnected, function() {\n      debug('disconnected');\n      self.emit('disconnected');\n      self.emit(AMQPClient.ConnectionClosed);\n      if (!self._shouldReconnect()) {\n        self._clearConnectionState(false);\n        return reject(new errors.DisconnectedError());\n      }\n\n      if (!self._timeouts.length)\n        self._timeouts = u.generateTimeouts(self.policy.reconnect);\n\n      setTimeout(function() {\n        return self._attemptReconnection().then(function() { resolve(self); });\n      }, self._timeouts.shift());\n    });\n\n    self._connection.open(address, sasl);\n  });\n};\n\n/**\n * Creates a sender link for the given address, with optional link policy\n *\n * @inner @memberof AMQPClient\n * @param {string} address                An address to connect this link to. If not provided will use default queue from connection uri.\n * @param {object} [policyOverrides]      Policy overrides used for creating this sender link\n * @param {string} [policyOverrides.name] Explicitly set a name for this link, this is an alias to [policyOverrides.attach.name]\n *\n * @return {Promise<SenderLink>}\n */\nAMQPClient.prototype.createSender = function(address, policyOverrides) {\n  if (!this._connection) {\n    throw new Error('Must connect before creating links');\n  }\n\n  address = this.policy.parseLinkAddress(address || this._defaultQueue);\n  policyOverrides = policyOverrides || {};\n\n  var linkName = u.linkName(address.name, policyOverrides),\n      linkPolicy = u.deepMerge(policyOverrides, {\n        attach: {\n          name: linkName,\n          source: { address: 'localhost' },\n          target: { address: address.name }\n        }\n      }, this.policy.senderLink);\n\n  if (!!address.subject && this.policy.defaultSubjects) {\n    if (address.subject === 'undefined' || address.subject === 'null') {\n      throw new errors.InvalidSubjectError(address.subject);\n    }\n\n    linkPolicy.defaultSubject = address.subject;\n  }\n\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var attach = function() {\n      var attachPromise = function(_err, _link) {\n        if (!!_err) return reject(_err);\n        return resolve(_link);\n      };\n\n      var link = self._session.createLink(linkPolicy);\n      link._onAttach.push(attachPromise);\n    };\n\n    attach();\n  });\n};\n\n/**\n * Creates a sender link wrapped as a Writable stream\n *\n * @inner @memberof AMQPClient\n * @param {string} address                Address used for link creation\n * @param {object} [policyOverrides]      Policy overrides used for creating this sender link\n *\n * @return {Promise<SenderStream>}\n */\nAMQPClient.prototype.createSenderStream = function(address, policyOverrides) {\n  return this.createSender(address, policyOverrides)\n    .then(function(link) { return new SenderStream(link, policyOverrides); });\n};\n\n/**\n * Creates a receiver link for the given address, with optional link policy. The\n * promise returned resolves to a link that is an EventEmitter, which can be\n * used to listen for 'message' events.\n *\n * @inner @memberof AMQPClient\n * @param {string} address                An address to connect this link to.  If not provided will use default queue from connection uri.\n * @param {object} [policyOverrides]      Policy overrides used for creating this receiver link\n * @param {string} [policyOverrides.name] Explicitly set a name for this link, this is an alias to [policyOverrides.attach.name]\n *\n * @return {Promise<ReceiverLink>}\n */\nAMQPClient.prototype.createReceiver = function(address, policyOverrides) {\n  if (!this._connection) {\n    throw new Error('Must connect before creating links');\n  }\n\n  address = this.policy.parseLinkAddress(address || this._defaultQueue);\n  policyOverrides = policyOverrides || {};\n\n  var linkName = u.linkName(address.name, policyOverrides),\n      linkPolicy = u.deepMerge(policyOverrides, {\n        attach: {\n          name: linkName,\n          source: { address: address.name },\n          target: { address: 'localhost' }\n        }\n      }, this.policy.receiverLink);\n\n  // if a subject has been provided then automatically set up a filter to\n  // match on that subject.\n  if (!!address.subject) {\n    if (address.subject === 'undefined' || address.subject === 'null') {\n      throw new errors.InvalidSubjectError(address.subject);\n    }\n\n    var filterSymbol = (address.subject.indexOf('*') || address.subject.indexOf('#')) ?\n      'apache.org:legacy-amqp-topic-binding:string' :\n      'apache.org:legacy-amqp-direct-binding:string';\n\n    linkPolicy.attach.source.filter = {};\n    linkPolicy.attach.source.filter[filterSymbol] =\n      translator(['described', ['symbol', filterSymbol], ['string', address.subject]]);\n  }\n\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var attach = function() {\n      var attachPromise = function(_err, _link) {\n        if (!!_err) return reject(_err);\n        return resolve(_link);\n      };\n\n      var link = self._session.createLink(linkPolicy);\n      link._onAttach.push(attachPromise);\n    };\n\n    attach();\n  });\n};\n\n/**\n * Creates a receiver link wrapped as a Readable stream\n *\n * @inner @memberof AMQPClient\n * @param {string} address                Address used for link creation\n * @param {object} [policyOverrides]      Policy overrides used for creating the receiver link\n *\n * @return {Promise<ReceiverStream>}\n */\nAMQPClient.prototype.createReceiverStream = function(address, policyOverrides) {\n  // Override default credit behavior, as the stream will handle flow. The\n  // creditQuantum will be used as the stream's highWatermark by default.\n  policyOverrides = u.deepMerge({\n    credit: function() {},\n  }, policyOverrides || {});\n\n  return this.createReceiver(address, policyOverrides)\n    .then(function(link) { return new ReceiverStream(link); });\n};\n\n/**\n * Disconnect tears down any existing connection with appropriate Close\n * performatives and TCP socket teardowns.\n *\n * @inner @memberof AMQPClient\n * @return {Promise}\n */\nAMQPClient.prototype.disconnect = function() {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    debug('disconnecting');\n    if (self._connection) {\n      self._preventReconnect();\n      var connection = self._connection;\n      self._clearConnectionState();\n      connection.once(Connection.Disconnected, function() {\n        debug('disconnected');\n        self.emit('disconnected');\n        connection = undefined;\n        resolve();\n      });\n      connection.close();\n    } else {\n      self.emit('disconnected');\n      resolve(); // Already disconnected, just deliver the promise.\n    }\n  });\n};\n\nAMQPClient.prototype._clearConnectionState = function(saveReconnectDetails) {\n  if (!!this._connection) this._connection.removeAllListeners();\n  this._connection = null;\n  if (!saveReconnectDetails) {\n    this._reconnect = null;\n  }\n\n  if (this._session) this._session._resetLinkState();\n};\n\n// Helper methods for mocking in tests.\nAMQPClient.prototype._newConnection = function(connectPolicy) {\n  var self = this;\n  var connection = new Connection(connectPolicy);\n  connection.on(Connection.ErrorReceived, function(e) {\n    debug('connection error: ', e);\n    self.emit(AMQPClient.ErrorReceived, e);\n  });\n\n  return connection;\n};\n\nAMQPClient.prototype._newSession = function(conn) {\n  var self = this;\n  var session = new Session(conn);\n  session.on(Session.Unmapped, function(s) {\n    debug('unmapped');\n  });\n\n  session.on(Session.ErrorReceived, function(e) {\n    debug('session error: ', e);\n    self.emit(AMQPClient.ErrorReceived, e);\n  });\n\n  return session;\n};\n\nAMQPClient.prototype._preventReconnect = function() {\n  this._reconnect = null;\n};\n\nAMQPClient.prototype._shouldReconnect = function() {\n  if (!this._connection || !this._reconnect) return false;\n  if (!this._timeouts ||\n      !this._timeouts.length && !this.policy.reconnect.forever) return false;\n  return true;\n};\n\nAMQPClient.prototype._attemptReconnection = function() {\n  this._clearConnectionState(true);\n\n  var self = this;\n  return self._reconnect()\n    .catch(function(err) {\n      self.emit(AMQPClient.ErrorReceived, err);\n\n      // @todo: this is problematic, since we're not passing the reconnect\n      //        promise back to sender. As such, it will signal two uncaught\n      //        exceptions, and then dump and quit the program. Need to find a\n      //        better way to tie the reconnect promise to the original request.\n      // if (!self._shouldReconnect())\n      //   throw err;  // rethrow\n    });\n};\n\nmodule.exports = AMQPClient;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/connection.js":"'use strict';\nvar EventEmitter = require('events').EventEmitter,\n    fs = require('fs'),\n    util = require('util'),\n\n    debug = require('debug')('amqp10:connection'),\n    debugTRACE = require('debug')('amqp10:trace'),\n    BufferList = require('bl'),\n    StateMachine = require('stately.js'),\n\n    constants = require('./constants'),\n    errors = require('./errors'),\n    frames = require('./frames'),\n    u = require('./utilities'),\n\n    ErrorCondition = require('./types/error_condition'),\n    TransportProvider = require('./transport');\n\n\n\n/**\n * Connection states, from AMQP 1.0 spec:\n *\n <dl>\n <dt>START</dt>\n <dd><p>In this state a Connection exists, but nothing has been sent or received. This is the\n state an implementation would be in immediately after performing a socket connect or\n socket accept.</p></dd>\n\n <dt>HDR-RCVD</dt>\n <dd><p>In this state the Connection header has been received from our peer, but we have not\n yet sent anything.</p></dd>\n\n <dt>HDR-SENT</dt>\n <dd><p>In this state the Connection header has been sent to our peer, but we have not yet\n received anything.</p></dd>\n\n <dt>OPEN-PIPE</dt>\n <dd><p>In this state we have sent both the Connection header and the open frame, but we have not yet received anything.\n </p></dd>\n\n <dt>OC-PIPE</dt>\n <dd><p>In this state we have sent the Connection header, the open\n frame, any pipelined Connection traffic, and the close frame,\n but we have not yet received anything.</p></dd>\n\n <dt>OPEN-RCVD</dt>\n <dd><p>In this state we have sent and received the Connection header, and received an\n open frame from our peer, but have not yet sent an\n open frame.</p></dd>\n\n <dt>OPEN-SENT</dt>\n <dd><p>In this state we have sent and received the Connection header, and sent an\n open frame to our peer, but have not yet received an\n open frame to our peer, but have not yet received an\n open frame.</p></dd>\n\n <dt>CLOSE-PIPE</dt>\n <dd><p>In this state we have send and received the Connection header, sent an\n open frame, any pipelined Connection traffic, and the\n close frame, but we have not yet received an\n open frame.</p></dd>\n\n <dt>OPENED</dt>\n <dd><p>In this state the Connection header and the open frame\n have both been sent and received.</p></dd>\n\n <dt>CLOSE-RCVD</dt>\n <dd><p>In this state we have received a close frame indicating\n that our partner has initiated a close. This means we will never have to read anything\n more from this Connection, however we can continue to write frames onto the Connection.\n If desired, an implementation could do a TCP half-close at this point to shutdown the\n read side of the Connection.</p></dd>\n\n <dt>CLOSE-SENT</dt>\n <dd><p>In this state we have sent a close frame to our partner.\n It is illegal to write anything more onto the Connection, however there may still be\n incoming frames. If desired, an implementation could do a TCP half-close at this point\n to shutdown the write side of the Connection.</p></dd>\n\n <dt>DISCARDING</dt>\n <dd><p>The DISCARDING state is a variant of the CLOSE_SENT state where the\n close is triggered by an error. In this case any incoming frames on\n the connection MUST be silently discarded until the peer's close frame\n is received.</p></dd>\n\n <dt>END</dt>\n <dd><p>In this state it is illegal for either endpoint to write anything more onto the\n Connection. The Connection may be safely closed and discarded.</p></dd>\n </dl>\n *\n * Connection negotiation state diagram from AMQP 1.0 spec:\n *\n <pre>\n              R:HDR +=======+ S:HDR             R:HDR[!=S:HDR]\n           +--------| START |-----+    +--------------------------------+\n           |        +=======+     |    |                                |\n          \\\\|/                    \\\\|/   |                                |\n      +==========+             +==========+ S:OPEN                      |\n +----| HDR-RCVD |             | HDR-SENT |------+                      |\n |    +==========+             +==========+      |      R:HDR[!=S:HDR]  |\n |   S:HDR |                      | R:HDR        |    +-----------------+\n |         +--------+      +------+              |    |                 |\n |                 \\\\|/    \\\\|/                   \\\\|/   |                 |\n |                +==========+               +-----------+ S:CLOSE      |\n |                | HDR-EXCH |               | OPEN-PIPE |----+         |\n |                +==========+               +-----------+    |         |\n |           R:OPEN |      | S:OPEN              | R:HDR      |         |\n |         +--------+      +------+      +-------+            |         |\n |        \\\\|/                    \\\\|/    \\\\|/                  \\\\|/        |\n |   +===========+             +===========+ S:CLOSE       +---------+  |\n |   | OPEN-RCVD |             | OPEN-SENT |-----+         | OC-PIPE |--+\n |   +===========+             +===========+     |         +---------+  |\n |  S:OPEN |                      | R:OPEN      \\\\|/           | R:HDR   |\n |         |       +========+     |          +------------+   |         |\n |         +----- >| OPENED |< ---+          | CLOSE-PIPE |< -+         |\n |                 +========+                +------------+             |\n |           R:CLOSE |    | S:CLOSE              | R:OPEN               |\n |         +---------+    +-------+              |                      |\n |        \\\\|/                    \\\\|/             |                      |\n |   +============+          +=============+     |                      |\n |   | CLOSE-RCVD |          | CLOSE-SENT* |< ---+                      |\n |   +============+          +=============+                            |\n | S:CLOSE |                      | R:CLOSE                             |\n |         |         +=====+      |                                     |\n |         +------- >| END |< ----+                                     |\n |                   +=====+                                            |\n |                     /|\\                                              |\n |    S:HDR[!=R:HDR]    |                R:HDR[!=S:HDR]                 |\n +----------------------+-----------------------------------------------+\n\n </pre>\n *\n * R:<b>CTRL</b> = Received <b>CTRL</b>\n *\n * S:<b>CTRL</b> = Sent <b>CTRL</b>\n *\n * Also could be DISCARDING if an error condition triggered the CLOSE\n *\n * @param connectPolicy ConnectPolicy from a Policy instance\n * @constructor\n */\nfunction Connection(connectPolicy) {\n  Connection.super_.call(this);\n\n  var options = connectPolicy.options;\n  u.assertArguments(options, ['containerId', 'hostname']);\n  this.policy = connectPolicy;\n  this._transport = null;\n  this.connected = false;\n  this.connectedTo = null;\n  this._buffer = new BufferList();\n  this._heartbeatInterval = undefined;\n\n  this.local = { open: new frames.OpenFrame(options) };\n  this.remote = {};\n\n  this._sslOptions = null;\n  if (options.sslOptions) {\n    this._sslOptions = options.sslOptions;\n\n    if (options.sslOptions.keyFile) {\n      this._sslOptions.key = fs.readFileSync(options.sslOptions.keyFile);\n      delete this._sslOptions.keyFile;\n    }\n    if (options.sslOptions.certFile) {\n      this._sslOptions.cert = fs.readFileSync(options.sslOptions.certFile);\n      delete this._sslOptions.certFile;\n    }\n    if (options.sslOptions.caFile) {\n      this._sslOptions.ca = fs.readFileSync(options.sslOptions.caFile);\n      delete this._sslOptions.caFile;\n    }\n  }\n\n  this._lastOutgoing = null; // To track whether heartbeat frame required.\n  this._receivedHeader = false;\n  this._sessions = {};\n  var self = this;\n  var stateMachine = {\n    'DISCONNECTED': {\n      connect: function(address, sasl) {\n        self._connect(address, sasl);\n        return this.START;\n      }\n    },\n    'START': {\n      connected: function(sasl) {\n        if (sasl) {\n          self.sasl = sasl;\n          self.sasl.negotiate(self, self.address, function(e) { self._saslComplete(e); });\n          return this.IN_SASL;\n        } else {\n          self.sendHeader();\n          return this.HDR_SENT;\n        }\n      },\n      headerReceived: function() { return this.HDR_RCVD; }\n    },\n    'IN_SASL': {\n      success: function() {\n        self.sendHeader();\n        return this.HDR_SENT;\n      }\n    },\n    'HDR_RCVD': {\n      validVersion: function() {\n        self.sendHeader();\n        return this.HDR_EXCH;\n      },\n      invalidVersion: function() {\n        self._terminate();\n        return this.DISCONNECTING;\n      }\n    },\n    'HDR_SENT': {\n      validVersion: function() {\n        return this.HDR_EXCH;\n      },\n      invalidVersion: function() {\n        self._terminate();\n        return this.DISCONNECTING;\n      }\n    },\n    'HDR_EXCH': {\n      sendOpen: function() {\n        self._sendOpenFrame();\n        return this.OPEN_SENT;\n      },\n      openReceived: function() {\n        return this.OPEN_RCVD;\n      }\n    },\n    'OPEN_RCVD': {\n      sendOpen: function() {\n        self._sendOpenFrame();\n        return this.OPENED;\n      }\n    },\n    'OPEN_SENT': {\n      openReceived: function() {\n        return this.OPENED;\n      },\n      sendClose: function() {\n        self._terminate();\n        return this.DISCONNECTED;\n      }\n    },\n    'OPENED': {\n      closeReceived: function() {\n        return this.CLOSE_RCVD;\n      },\n      invalidOptions: function() {\n        self._sendCloseFrame(ErrorCondition.ConnectionForced, 'Invalid options');\n        return this.CLOSE_SENT;\n      },\n      sendClose: function() {\n        self._sendCloseFrame();\n        return this.CLOSE_SENT;\n      }\n    },\n    'CLOSE_RCVD': {\n      sendClose: function() {\n        self._sendCloseFrame();\n        self._terminate();\n        return this.DISCONNECTED;\n      }\n    },\n    'CLOSE_SENT': {\n      closeReceived: function() {\n        self._terminate();\n        return this.DISCONNECTED;\n      },\n      disconnect: function() { return this.DISCONNECTED; }\n    },\n    'DISCONNECTING': {\n      disconnected: function() {\n        return this.DISCONNECTED;\n      }\n    }\n  };\n\n  var errorHandler = function(err) { self._processError(err); return this.DISCONNECTED; };\n  var terminationHandler = function() { self._terminate(); return this.DISCONNECTED; };\n  Object.keys(stateMachine).forEach(function(state) {\n    if (state !== 'DISCONNECTED') {\n      stateMachine[state].error = errorHandler;\n      stateMachine[state].terminated = terminationHandler;\n    }\n  });\n\n  this.connSM = new StateMachine(stateMachine).bind(function(event, oldState, newState) {\n    debug('stateChange:', oldState, '=>', newState, ', reason:', event);\n  });\n}\n\nutil.inherits(Connection, EventEmitter);\n\n// Events\nConnection.Connected = 'connection:connected';\nConnection.Disconnected = 'connection:disconnected';\n\n// On receipt of a frame not handled internally (e.g. not a BEGIN/CLOSE/SASL).\n// Provides received frame as an argument.\nConnection.FrameReceived = 'connection:frameReceived';\n\n// Since 'error' events are \"special\" in Node (as in halt-the-process special),\n// using a custom event for errors we receive from the other endpoint. Provides\n// received AMQPError as an argument.\nConnection.ErrorReceived = 'connection:errorReceived';\n\n\n/**\n * Open a connection to the given (parsed) address (@see {@link AMQPClient}).\n *\n * @param address   Contains at least protocol, host and port, may contain user/pass, path.\n * @param sasl      If given, contains a \"negotiate\" method that, given address and a callback, will run through SASL negotiations.\n */\nConnection.prototype.open = function(address, sasl) {\n  this.connSM.connect(address, sasl);\n};\n\nConnection.prototype.close = function() {\n  this.connSM.sendClose();\n};\n\nConnection.prototype.sendFrame = function(frame, callback) {\n  this._lastOutgoing = Date.now();\n  frames.writeFrame(frame, this._transport, callback);\n};\n\nConnection.prototype.associateSession = function(session) {\n  var channel = this._nextChannel();\n  this._sessions[channel] = session;\n  return channel;\n};\n\nConnection.prototype.dissociateSession = function(channel) {\n  this._sessions[channel] = undefined;\n};\n\nConnection.prototype._nextChannel = function() {\n  for (var cid = 1; cid <= this.remote.open.channelMax; ++cid) {\n    if (this._sessions[cid] === undefined) return cid;\n  }\n  throw new errors.OverCapacityError('Out of available ' + this.remote.open.channelMax + ' channels');\n};\n\nConnection.prototype._processError = function(err) {\n  debug('Error from socket: ' + err);\n  this.emit(Connection.ErrorReceived, errors.wrapProtocolError(err));\n  this._terminate(err);\n};\n\nConnection.prototype._receiveData = function(buffer) {\n  debugTRACE('Rx: ' + buffer.toString('hex'));\n  this._buffer.append(buffer);\n  this._receiveAny();\n};\n\nConnection.prototype.sendHeader = function(header) {\n  header = header || constants.amqpVersion;\n  debug('Sending Header ' + header.toString('hex'));\n  this._transport.write(header);\n};\n\nConnection.prototype._tryReceiveHeader = function(header) {\n  header = header || constants.amqpVersion;\n  if (this._buffer.length >= header.length) {\n    var serverVersion = this._buffer.slice(0, 8);\n    this._buffer.consume(8);\n\n    if (this.sasl) {\n      this.sasl.headerReceived(serverVersion);\n    } else {\n      debug('Server AMQP Version: ' + serverVersion.toString('hex') + ' vs ' + header.toString('hex'));\n      if (this.connSM.getMachineState() === 'START') {\n        this.connSM.headerReceived();\n      }\n\n      if (u.bufferEquals(serverVersion, constants.amqpVersion)) {\n        this.connSM.validVersion();\n        this.connSM.sendOpen();\n      } else {\n        var msg = 'Invalid AMQP version received: ';\n        if (u.bufferEquals(serverVersion, constants.saslVersion)) {\n          msg = 'Credentials Expected - SASL version received: ';\n        }\n        this.emit(Connection.ErrorReceived, new errors.VersionError(msg + serverVersion.toString('hex')));\n        this.connSM.invalidVersion();\n      }\n      this._receivedHeader = true;\n    }\n\n    return true;\n  }\n  return false;\n};\n\nConnection.prototype._receiveAny = function() {\n  var frame = null;\n  while (true) {\n    if (this.sasl && !this.sasl.receivedHeader) {\n      if (!this._tryReceiveHeader(constants.saslVersion)) break;\n    } else if (!this.sasl && !this._receivedHeader) {\n      if (!this._tryReceiveHeader()) break;\n    }\n\n    try {\n      frame = frames.readFrame(this._buffer);\n    } catch (e) {\n      var self = this;\n      this._sendCloseFrame(ErrorCondition.ConnectionFramingError, e.message, function(err) {  // jshint ignore:line\n        self._terminate(true);\n      });\n\n      break;\n    }\n\n    if (!frame) break;\n    if (frame instanceof frames.OpenFrame) {\n      this._processOpenFrame(frame);\n    } else if (frame instanceof frames.CloseFrame) {\n      this._processCloseFrame(frame);\n      break;\n    } else {\n      this.emit(Connection.FrameReceived, frame);\n    }\n  }\n};\n\nConnection.prototype._ensureLocaleCompatibility = function(lhsLocales, rhsLocales) {\n  return true;\n};\n\nConnection.prototype._sendOpenFrame = function() {\n  this.sendFrame(this.local.open);\n};\n\nConnection.prototype._processOpenFrame = function(frame) {\n  this.connSM.openReceived();\n  if (this.connSM.getMachineState() === 'OPEN_RCVD') {\n    this.connSM.sendOpen();\n  }\n\n  var valid = true;\n  this.remote.open = frame;\n  if (this.remote.open.outgoingLocales) {\n    valid = valid &&\n      this._ensureLocaleCompatibility(this.local.open.incomingLocales, this.remote.open.outgoingLocales);\n  }\n  if (this.remote.open.incomingLocales) {\n    valid = valid &&\n      this._ensureLocaleCompatibility(this.local.open.outgoingLocales, this.remote.open.incomingLocales);\n  }\n\n  if (!valid) {\n    return this.connSM.invalidOptions();\n  }\n\n  // We're connected.\n  debug('Connected with params { maxFrameSize=', this.remote.open.maxFrameSize,\n        ', channelMax=', this.remote.open.channelMax, ', idleTimeout=',\n        this.local.open.idleTimeout, ', remoteIdleTimeout=', this.remote.open.idleTimeout,\n        ' }');\n  this.connected = true;\n  this._lastOutgoing = Date.now();\n  if (this.remote.open.idleTimeout && Number(this.remote.open.idleTimeout) > 0) {\n    var maxTimeBeforeHeartbeat = Math.floor(this.remote.open.idleTimeout / 2);\n    var timeBetweenHeartbeatChecks = Math.floor(this.remote.open.idleTimeout / 8);\n\n    debug('Setting heartbeat check timeout to ' + timeBetweenHeartbeatChecks);\n    var self = this;\n    this._heartbeatInterval = setInterval(function() {\n      if (self.connected && self._transport && (Date.now() - self._lastOutgoing) > maxTimeBeforeHeartbeat) {\n        self.sendFrame(new frames.HeartbeatFrame());\n      }\n    }, timeBetweenHeartbeatChecks);\n  }\n\n  this.emit(Connection.Connected, this);\n  if (this._buffer.length) this._receiveAny(); // Might have more frames pending.\n};\n\nConnection.prototype._sendCloseFrame = function(condition, description, callback) {\n  var error = null;\n  if (!!condition) {\n    error = { condition: condition, description: description };\n  }\n\n  this.sendFrame(new frames.CloseFrame({ error: error }), callback);\n};\n\nConnection.prototype._processCloseFrame = function(frame) {\n  if (frame.error) {\n    this.emit(Connection.ErrorReceived, errors.wrapProtocolError(frame.error));\n  }\n\n  this.connSM.closeReceived();\n  this.connSM.sendClose();\n};\n\nConnection.prototype._connect = function(address, sasl) {\n  this.address = address;\n  var self = this;\n  self.dataHandler = self._receiveHeader;\n  self._transport = TransportProvider.getTransportFor(address.protocol);\n\n  if (!self._transport) {\n    throw new Error('Invalid protocol, no associated transport. Please use client.register(protocol, transport) to register a new transport.');\n  }\n\n  self._transport.connect(address, self._sslOptions);\n  self._transport\n    .on('connect', function() { self.connSM.connected(sasl); })\n    .on('data', function(buf) { self._receiveData(buf); })\n    .on('error', function(err) { self.connSM.error(err); })\n    .on('end', function() {\n      debug('on(end)');\n      self.connSM.terminated();\n    });\n};\n\nConnection.prototype._saslComplete = function(err) {\n  this.sasl = null;\n  if (err) {\n    this.connSM.error(err);\n  } else {\n    this.connSM.success();\n  }\n};\n\nConnection.prototype._terminate = function(hasError) {\n  var transport = this._transport;\n  this._transport = null;\n  this._sslOptions = null;\n  this.sasl = null;\n  this.address = null;\n  if (transport) {\n    transport.end();\n    if (hasError) {\n      transport.destroy();\n    }\n  }\n\n  if (this._heartbeatInterval) {\n    clearInterval(this._heartbeatInterval);\n    this._heartbeatInterval = undefined;\n  }\n\n  this.connected = false;\n  this.emit(Connection.Disconnected, this);\n};\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/frames.js":"'use strict';\nvar Builder = require('buffer-builder'),\n    DescribedType = require('./types/described_type'),\n    errors = require('./errors'),\n    codec = require('./codec'),\n    debug = require('debug')('amqp10:framing'),\n    trace = require('debug')('amqp10:trace'),\n    constants = require('./constants'),\n    defineComposite = require('./types/composite_type').defineComposite,\n    terminus = require('./types/terminus'),\n    util = require('util');\n\nvar frames = module.exports = {};\nvar framesByDescriptor = {};\n\nvar FrameType = { AMQP: 0x00, SASL: 0x01 };\nframes.Frame = function(type) { this.type = type; };\nframes.AMQPFrame = function(channel) {\n  frames.AMQPFrame.super_.call(this, constants.frameType.amqp);\n  this.channel = channel || 0;\n};\nutil.inherits(frames.AMQPFrame, frames.Frame);\n\nframes.SaslFrame = function() {\n  frames.SaslFrame.super_.call(this, constants.frameType.sasl);\n};\nutil.inherits(frames.SaslFrame, frames.Frame);\n\nframes.writeFrame = function(frame, stream, options, callback) {\n  if (!(frame instanceof frames.Frame)) {\n    throw new errors.EncodingError(frame, 'unknown frame type');\n  }\n\n  options = options || { verbose: true };\n  if (callback === undefined && typeof options === 'function') {\n    callback = options;\n  }\n\n  var builder = new Builder();\n  builder.appendUInt32BE(0); // size placeholder\n  builder.appendUInt8(2);  // doff, no extended headers\n  builder.appendUInt8(frame.type);\n  if (frame instanceof frames.AMQPFrame) {\n    builder.appendUInt16BE(frame.channel);\n  } else {\n    builder.appendUInt16BE(0);\n  }\n\n  var performative = frame.toDescribedType();\n  if (performative !== null && performative !== undefined) {\n    codec.encode(performative, builder);\n    if (frame instanceof frames.TransferFrame) {\n      if (frame.payload !== undefined) builder.appendBuffer(frame.payload);\n    }\n  }\n\n  var buffer = builder.get();\n  buffer.writeUInt32BE(buffer.length, 0);\n  if (options.verbose) {\n    debug('=>', frame);\n    trace('raw: [' + buffer.toString('hex') + ']');\n  }\n\n  stream.write(buffer, callback);\n};\n\nframes.readFrame = function(buffer, options) {\n  options = options || { verbose: true };\n  if (buffer.length < 8) return undefined;\n\n  var sizeAndDoff = buffer.slice(0, 8);\n  var size = sizeAndDoff.readUInt32BE(0);\n  var doff = sizeAndDoff.readUInt8(4);\n  if (doff !== 2) throw new errors.MalformedHeaderError('Invalid DOFF');\n  if (size > buffer.length) return undefined;\n\n  var frameType = sizeAndDoff[5];\n  if (frameType !== FrameType.AMQP && frameType !== FrameType.SASL) {\n    throw new errors.NotImplementedError('Unsupported frame type: ' + frameType);\n  }\n\n  // actually consume the bytes now that we have no errors\n  buffer.consume(8);\n\n  var payloadSize = size - (doff * 4);\n  if (payloadSize <= 0) {\n    // @todo: this is probably a heartbeat frame, but what if its not?\n    if (options.verbose) {\n      debug('<= (EMPTY FRAME)');\n      trace('raw: [' + sizeAndDoff.toString('hex') + ']');\n    }\n\n    return;\n  }\n\n  var xHeaderSize = (doff * 4) - 8;\n  if (xHeaderSize > 0) {\n    var xHeaderBuf = buffer.slice(0, xHeaderSize);\n    buffer.consume(xHeaderSize);\n\n    // @todo: Process x-header\n    if (options.verbose) {\n      debug('received extended header');\n      trace('raw: [' + xHeaderBuf.toString('hex') + ']');\n    }\n  }\n\n  // read payload\n  var payloadBuffer = buffer.slice(0, payloadSize);\n  buffer.consume(payloadSize);\n\n  // decode payload\n  var decodedPayload = codec.decode(payloadBuffer, 0);\n  if (!decodedPayload) {\n    throw new errors.MalformedPayloadError('Unable to parse frame payload [' + payloadBuffer.toString('hex') + ']');\n  }\n\n  if (!(decodedPayload[0] instanceof DescribedType)) {\n    throw new errors.MalformedPayloadError('Expected DescribedType from AMQP Payload, but received ' + JSON.stringify(decodedPayload[0]));\n  }\n\n  // read frame\n  var channel = sizeAndDoff.readUInt16BE(6); // Bytes 6 & 7 are channel\n  var messageBuffer = payloadBuffer.slice(decodedPayload[1]);\n\n  var described = decodedPayload[0];\n  if (!framesByDescriptor.hasOwnProperty(described.descriptor)) {\n    throw new errors.MalformedPayloadError('Unknown frame descriptor: ' + described.descriptor);\n  }\n\n  var frame = new framesByDescriptor[described.descriptor](described);\n  if (messageBuffer.length) frame.payload = messageBuffer;\n  if (frameType === FrameType.AMQP) {\n    frame.channel = channel;\n  }\n\n  if (options.verbose) {\n    debug('<=', frame);\n    trace('raw: [' + payloadBuffer.toString('hex') + ']');\n  }\n\n  return frame;\n};\n\nfunction defineFrame(type, definition) {\n  var FrameBase = (type === FrameType.AMQP) ? frames.AMQPFrame : frames.SaslFrame;\n  var Frame = defineComposite(FrameBase, definition);\n  framesByDescriptor[Frame.descriptor.code] = Frame;\n  framesByDescriptor[Frame.descriptor.name] = Frame;\n  return Frame;\n}\n\n// restricted type helpers\nfunction role(value) {\n  if (typeof value === 'boolean')\n    return value;\n\n  if (value !== 'sender' && value !== 'receiver')\n    throw new errors.EncodingError(value, 'invalid role');\n  return (value === 'sender') ? false : true;\n}\n\nvar ReceiverSettleModes = [ 'first', 'second', 'auto', 'settle' ];\nfunction receiverSettleMode(value) {\n  if (typeof value === 'number' || value instanceof Number)\n    return value;\n\n  if (ReceiverSettleModes.indexOf(value) === -1)\n    throw new errors.EncodingError(value, 'invalid receiver settle mode');\n  return (value === 'first' || value === 'auto') ? 0 : 1;\n}\n\nfunction senderSettleMode(value) {\n  if (typeof value === 'number' || value instanceof Number)\n    return value;\n\n  if (value !== 'unsettled' && value !== 'settled' && value !== 'mixed')\n    throw new errors.EncodingError(value, 'invalid sender settle mode');\n\n  if (value === 'unsettled') return 0;\n  else if (value === 'settled') return 1;\n  return 2;\n}\n\n// AMQP frames\nframes.OpenFrame = defineFrame(FrameType.AMQP, {\n  name: 'open', code: 0x10,\n  fields: [\n    { name: 'containerId', type: 'string', mandatory: true },\n    { name: 'hostname', type: 'string' },\n    { name: 'maxFrameSize', type: 'uint', default: constants.defaultMaxFrameSize },\n    { name: 'channelMax', type: 'ushort', default: constants.defaultChannelMax },\n    { name: 'idleTimeout', type: 'milliseconds', default: constants.defaultIdleTimeout },\n    { name: 'outgoingLocales', type: 'ietf-language-tag',\n      multiple: true, default: constants.defaultOutgoingLocales },\n    { name: 'incomingLocales', type: 'ietf-language-tag',\n      multiple: true, default: constants.defaultIncomingLocales },\n    { name: 'offeredCapabilities', type: 'symbol', multiple: true },\n    { name: 'desiredCapabilities', type: 'symbol', multiple: true },\n    { name: 'properties', type: 'fields', default: {} }\n  ]\n});\n\nframes.BeginFrame = defineFrame(FrameType.AMQP, {\n  name: 'begin', code: 0x11,\n  fields: [\n    { name: 'remoteChannel', type: 'ushort' },\n    { name: 'nextOutgoingId', type: 'transfer-number', mandatory: true },\n    { name: 'incomingWindow', type: 'uint', mandatory: true },\n    { name: 'outgoingWindow', type: 'uint', mandatory: true },\n    { name: 'handleMax', type: 'handle', default: constants.defaultHandleMax },\n    { name: 'offeredCapabilities', type: 'symbol', multiple: true },\n    { name: 'desiredCapabilities', type: 'symbol', multiple: true },\n    { name: 'properties', type: 'fields', default: {} }\n  ]\n});\n\nframes.AttachFrame = defineFrame(FrameType.AMQP, {\n  name: 'attach', code: 0x12,\n  fields: [\n    { name: 'name', type: 'string', mandatory: true },\n    { name: 'handle', type: 'handle', mandatory: true },\n    { name: 'role', type: 'boolean', requires: role, mandatory: true },\n    { name: 'sndSettleMode', type: 'ubyte', requires: senderSettleMode, default: 'mixed' },\n    { name: 'rcvSettleMode', type: 'ubyte', requires: receiverSettleMode, default: 'auto' },\n    { name: 'source', type: '*', requires: terminus.Source },\n    { name: 'target', type: '*', requires: terminus.Target },\n    { name: 'unsettled', type: 'map', default: {} },\n    { name: 'incompleteUnsettled', type: 'boolean', default: false },\n    { name: 'initialDeliveryCount', type: 'sequence-no' },\n    { name: 'maxMessageSize', type: 'ulong', default: 0 },\n    { name: 'offeredCapabilities', type: 'symbol', multiple: true },\n    { name: 'desiredCapabilities', type: 'symbol', multiple: true },\n    { name: 'properties', type: 'fields', default: {} }\n  ]\n});\n\nframes.FlowFrame = defineFrame(FrameType.AMQP, {\n  name: 'flow', code: 0x13,\n  fields: [\n    { name:'nextIncomingId', type: 'transfer-number' },\n    { name:'incomingWindow', type: 'uint', mandatory: true },\n    { name:'nextOutgoingId', type: 'transfer-number', mandatory: true },\n    { name:'outgoingWindow', type: 'uint', mandatory: true },\n    { name:'handle', type: 'handle' },\n    { name:'deliveryCount', type: 'sequence-no' },\n    { name:'linkCredit', type: 'uint' },\n    { name:'available', type: 'uint' },\n    { name:'drain', type: 'boolean', default: false },\n    { name:'echo', type: 'boolean', default: false },\n    { name:'properties', type: 'fields', default: {} }\n  ]\n});\n\nframes.TransferFrame = defineFrame(FrameType.AMQP, {\n  name: 'transfer', code: 0x14,\n  fields:[\n    { name: 'handle', type: 'handle', mandatory: true },\n    { name: 'deliveryId', type: 'delivery-number' },\n    { name: 'deliveryTag', type: 'delivery-tag' },\n    { name: 'messageFormat', type: 'message-format', default: 0 },\n    { name: 'settled', type: 'boolean' },\n    { name: 'more', type: 'boolean', default: false },\n    { name: 'rcvSettleMode', type: 'ubyte', requires: receiverSettleMode, default: 'auto' },\n    { name: 'state', type: '*' /* @todo: requires: deliveryState */ },\n    { name: 'resume', type: 'boolean', default: false },\n    { name: 'aborted', type: 'boolean', default: false },\n    { name: 'batchable', type: 'boolean', default: false }\n  ]\n});\n\nframes.DispositionFrame = defineFrame(FrameType.AMQP, {\n  name: 'disposition', code: 0x15,\n  fields:[\n    { name: 'role', type: 'boolean', requires: role, mandatory: true },\n    { name: 'first', type: 'delivery-number', mandatory: true },\n    { name: 'last', type: 'delivery-number' },\n    { name: 'settled', type: 'boolean', default: false },\n    { name: 'state', type: '*' /* @todo: requires: deliveryState */ },\n    { name: 'batchable', type: 'boolean', default: false }\n  ]\n});\n\nframes.DetachFrame = defineFrame(FrameType.AMQP, {\n  name: 'detach', code: 0x16,\n  fields: [\n    { name: 'handle', type: 'handle', mandatory: true },\n    { name: 'closed', type: 'boolean', default: false },\n    { name: 'error', type: 'error' }\n  ]\n});\n\nframes.EndFrame = defineFrame(FrameType.AMQP, {\n  name: 'end', code: 0x17,\n  fields: [\n    { name: 'error', type: 'error' }\n  ]\n});\n\nframes.CloseFrame = defineFrame(FrameType.AMQP, {\n  name: 'close', code: 0x18,\n  fields: [\n    { name: 'error', type: 'error' }\n  ]\n});\n\n// SASL frames\nframes.SaslMechanismsFrame = defineFrame(FrameType.SASL, {\n  name: 'sasl-mechanisms', code: 0x40,\n  fields: [\n    { name: 'saslServerMechanisms', type: 'symbol', multiple: true, mandatory: true }\n  ]\n});\n\nframes.SaslInitFrame = defineFrame(FrameType.SASL, {\n  name: 'sasl-init', code: 0x41,\n  fields: [\n    { name: 'mechanism', type: 'symbol', mandatory: true },\n    { name: 'initialResponse', type: 'binary' },\n    { name: 'hostname', type: 'string' }\n  ]\n});\n\nframes.SaslChallengeFrame = defineFrame(FrameType.SASL, {\n  name: 'sasl-challenge', code: 0x42,\n  fields: [\n    { name: 'challenge', type: 'binary', mandatory: true }\n  ]\n});\n\nframes.SaslResponseFrame = defineFrame(FrameType.SASL, {\n  name: 'sasl-response', code: 0x43,\n  fields: [\n    { name: 'response', type: 'binary', mandatory: true }\n  ]\n});\n\nframes.SaslOutcomeFrame = defineFrame(FrameType.SASL, {\n  name: 'sasl-outcome', code: 0x44,\n  fields: [\n    { name: 'code', type: 'ubyte', mandatory: true },\n    { name: 'additionalData', type: 'binary' }\n  ]\n});\n\n// special frames\nframes.HeartbeatFrame = function() {\n  frames.AMQPFrame.call(this, 0);\n};\nframes.HeartbeatFrame.prototype = Object.create(frames.AMQPFrame.prototype);\nframes.HeartbeatFrame.prototype.toDescribedType = function() { return null; };\nframes.HeartbeatFrame.prototype.inspect = function(depth) {\n  return '(EMPTY FRAME)';\n};\n\n// used to determine if a message should be split to multiple frames\nframes.TRANSFER_FRAME_OVERHEAD = 29;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/codec.js":"'use strict';\n\nvar Int64 = require('node-int64'),\n\n    AMQPArray = require('./types/amqp_composites').Array,\n    DescribedType = require('./types/described_type'),\n    ForcedType = require('./types/forced_type'),\n\n    types = require('./types'),\n    errors = require('./errors'),\n    u = require('./utilities');\n\n/**\n * Build a codec.\n *\n * @constructor\n */\nvar Codec = function() {};\nCodec.prototype._peek = function(buf, offset, numBytes) {\n  return buf.slice(offset, offset + numBytes);\n};\n\nCodec.prototype._read = function(buf, offset, numBytes) {\n  return buf.slice(offset, offset + numBytes);\n};\n\nCodec.prototype._readOrPeekFixed = function(buf, offset, remaining, doNotConsume, numBytes) {\n  var reader = doNotConsume ? this._peek : this._read;\n  return remaining >= numBytes ?\n    [ reader(buf, offset, numBytes), numBytes ] : undefined;\n};\n\n/**\n * Reads a full value's worth of bytes from a circular or regular buffer, or returns undefined if not enough bytes are there.\n * Note that for Buffers, the returned Buffer will be a slice (so backed by the original storage)!\n *\n * @param {Buffer|CBuffer} buf              Buffer or circular buffer to read from.  If a Buffer is given, it is assumed to be full.\n * @param {integer} [offset=0]              Offset - only valid for Buffer, not CBuffer.\n * @param {boolean} [doNotConsume=false]    If set to true, will peek bytes instead of reading them - useful for leaving\n *                                          circular buffer in original state for described values that are not yet complete.\n * @param {Number} [forcedCode]             If given, first byte is not assumed to be code and given code will be used - useful for arrays.\n * @return {Array}                         Buffer of full value + number of bytes read.\n *                                          For described types, will return [ [ descriptor-buffer, value-buffer ], total-bytes ].\n * @private\n */\nCodec.prototype._readFullValue = function(buf, offset, doNotConsume, forcedCode) {\n  offset = offset || 0;\n  var remaining = buf.length - offset;\n  if (remaining < 1) return undefined;\n\n  var code = forcedCode;\n  var codeBytes = 0;\n  if (code === undefined) {\n    code = this._peek(buf, offset, 1)[0];\n    codeBytes = 1;\n  }\n\n  // Constructor - need to read two full values back to back of unknown size.  (╯°□°）╯︵ ┻━┻\n  if (code === 0x00) {\n    var val1 = this._readFullValue(buf, offset + codeBytes, true);\n    if (val1 !== undefined) {\n      var val2 = this._readFullValue(buf, offset + codeBytes + val1[1], true);\n      if (val2 !== undefined) {\n        var totalBytes = val1[1] + val2[1] + codeBytes;\n        return [[val1[0], val2[0]], totalBytes];\n      }\n    }\n\n    return undefined;\n  }\n\n  var codePrefix = code & 0xF0;\n  var codeAndLength, numBytes;\n  switch (codePrefix) {\n    case 0x40: return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, 0 + codeBytes);\n    case 0x50: return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, 1 + codeBytes);\n    case 0x60: return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, 2 + codeBytes);\n    case 0x70: return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, 4 + codeBytes);\n    case 0x80: return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, 8 + codeBytes);\n    case 0x90: return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, 16 + codeBytes);\n    case 0xA0:\n    case 0xC0:\n    case 0xE0:\n      if (remaining < 2) return undefined;\n      codeAndLength = this._peek(buf, offset, codeBytes + 1);\n      numBytes = codeAndLength[codeBytes] + 1 + codeBytes; // code + size + # octets\n      //debug('Reading variable with prefix 0x'+codePrefix.toString(16)+' of length '+numBytes);\n      return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, numBytes);\n    case 0xB0:\n    case 0xD0:\n    case 0xF0:\n      if (remaining < 5) return false;\n      codeAndLength = this._peek(buf, offset, codeBytes + 4);\n      numBytes = codeAndLength.readUInt32BE(codeBytes) + 4 + codeBytes; // code + size + #octets\n      //debug('Reading variable with prefix 0x'+codePrefix.toString(16)+' of length '+numBytes);\n      return this._readOrPeekFixed(buf, offset, remaining, doNotConsume, numBytes);\n    default:\n      throw new errors.MalformedPayloadError('Unknown code prefix: 0x' + codePrefix.toString(16));\n  }\n};\n\nCodec.prototype._asMostSpecific = function(buf, forcedCode) {\n  if (buf instanceof Array) {\n    // Described type\n    var descriptor = this._asMostSpecific(buf[0]);\n    var value = this._asMostSpecific(buf[1]);\n    var describedType = new DescribedType(descriptor, value);\n    return describedType;\n  }\n\n  var code = forcedCode || buf[0];\n  if (!types.hasOwnProperty(code)) {\n    throw new errors.MalformedPayloadError('Unknown code: 0x' + code.toString(16));\n  }\n\n  var decoder = types[code];\n  var valBytes = forcedCode ? buf : buf.slice(1);\n  return decoder.decode(valBytes, this);\n};\n\n\n/**\n * Decode a single entity from a buffer (starting at offset 0).  Only simple values currently supported.\n *\n * @param {Buffer|CBuffer} buf          The buffer/circular buffer to decode.  Will decode a single value per call.\n * @param {Number} [offset=0]           The offset to read from (only used for Buffers).\n * @param {Number} [forcedCode]         If given, will not consume first byte for code and will instead use this as the code. Useful for arrays.\n * @return {Array}                      Single decoded value + number of bytes consumed.\n */\nCodec.prototype.decode = function(buf, offset, forcedCode) {\n  offset = offset || 0;\n  forcedCode = forcedCode || undefined;\n\n  var fullBuf = this._readFullValue(buf, offset, /* doNotConsume= */false, forcedCode);\n  if (fullBuf) {\n    var bufVal = fullBuf[0];\n    var numBytes = fullBuf[1];\n    var value = this._asMostSpecific(bufVal, forcedCode);\n    return [value, numBytes];\n  }\n\n  /** @todo: debug unmatched */\n  return undefined;\n};\n\n\n/**\n * Encode the given value as an AMQP 1.0 bitstring.\n *\n * We do a best-effort to determine type.  Objects will be encoded as <code>maps</code>, unless:\n * + They are DescribedTypes, in which case they will be encoded as such.\n * + They are Int64s, in which case they will be encoded as <code>longs</code>.\n *\n * @param value                         Value to encode.\n * @param {builder} buffer              buffer-builder to write into.\n * @param {string} [forceType]          If set, forces the encoder for the given type.\n */\nCodec.prototype.encode = function(value, buffer, forceType) {\n  // Special-case null values\n  if (value === null) {\n    return types.null.encode(value, buffer);\n  }\n\n  if (!!forceType) {\n    // @todo: this will unfortunately cause a deoptimization of the method\n    //        until at least node 4.2.1, because v8 will assume that lookups\n    //        by keyed value are done with a Number rather than a String\n    if (!types.hasOwnProperty(forceType)) throw new errors.EncodingError(forceType, 'unknown type ' + forceType);\n    var encoder = types[forceType];\n    if (!encoder.encode) {\n      throw new errors.NotImplementedError('encode(' + forceType + ')');\n    }\n\n    return encoder.encode(value, buffer, this);\n  }\n\n  switch (typeof value) {\n    case 'boolean': return types.boolean.encode(value, buffer);\n    case 'string': return types.string.encode(value, buffer);\n    case 'function': return this.encode(value(), buffer, forceType);\n    case 'object': return this._encodeObject(value, buffer);\n    case 'number': return this._encodeNumber(value, buffer);\n    default:\n      throw new errors.NotImplementedError('encode(' + (typeof value) + ')');\n  }\n};\n\nCodec.prototype._encodeNumber = function(value, buffer) {\n  if (isNaN(value) || !isFinite(value)) {\n    throw new errors.EncodingError(value, 'value is not a finite number');\n  }\n\n  if (Math.floor(value) - value !== 0) {\n    return types.double.encode(value, buffer);\n  } else if (value >= 0) {\n    if (value <= 0xFFFFFFFF)\n      return types.uint.encode(value, buffer);\n    return types.ulong.encode(value, buffer);\n  }\n\n  if (Math.abs(value) <= 0xFFFFFFFF)\n    return types.int.encode(value, buffer);\n  return types.long.encode(value, buffer);\n};\n\nCodec.prototype._encodeObject = function(value, buffer) {\n  if (value instanceof DescribedType) {\n    buffer.appendUInt8(0x00);\n\n    // NOTE: Described type constructors are either ulongs or a symbol. Here\n    //       we are checking if the passed in value is a number and forcing a\n    //       ulong encoding. For everything else we attempt to encode as a symbol.\n    var descriptor = (value.descriptor instanceof ForcedType) ? value.descriptor.value : value.descriptor;\n    var descriptorEncoder =\n      (typeof descriptor === 'number') ? types.ulong : types.symbol;\n    descriptorEncoder.encode(descriptor, buffer);\n    var describedValue = value.getValue();\n    describedValue = (!!describedValue || u.isNumber(describedValue)) ? describedValue : [];\n    this.encode(describedValue, buffer);\n    return;\n  }\n\n  // support for composite types\n  if (value.toDescribedType && typeof value.toDescribedType === 'function') {\n    return this.encode(value.toDescribedType() || [], buffer);\n  }\n\n  if (value instanceof Buffer) return types.binary.encode(value, buffer, this);\n  if (value instanceof AMQPArray) return types.array.encode(value, buffer, this);\n  if (value instanceof Array) return types.list.encode(value, buffer, this);\n  if (value instanceof Date) return types.timestamp.encode(new Int64(value.getTime()), buffer, this);\n  if (value instanceof ForcedType) return this.encode(value.value, buffer, value.typeName);\n\n  var encoder;\n  if (value instanceof Int64) {\n    encoder = (value < 0) ? types.long.encode : types.ulong.encode;\n    return encoder(value, buffer, this);\n  }\n\n  if (value.encode && (typeof value.encode === 'function')) {\n    return value.encode(this, buffer);\n  }\n\n  return types.map.encode(value, buffer, this);\n};\n\nmodule.exports = new Codec();\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/amqp_composites.js":"'use strict';\n\n/**\n * Encoding for AMQP Arrays - homogeneous typed collections.  Provides the CODE for the element type.\n *\n * @param {Array} arr           Array contents, should be encode-able to the given code type.\n * @param {Number} elementType  BYTE code-point for the array values (e.g. 0xA1).\n * @constructor\n */\nfunction AMQPArray(arr, elementType) {\n  this.array = arr;\n  this.elementType = elementType;\n}\n\nmodule.exports.Array = AMQPArray;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types.js":"'use strict';\nvar Builder = require('buffer-builder'),\n    Int64 = require('node-int64'),\n    errors = require('./errors'),\n    AMQPArray = require('./types/amqp_composites').Array,\n    AMQPError = require('./types/amqp_error'),\n    ForcedType = require('./types/forced_type'),\n    DescribedType = require('./types/described_type'),\n    u = require('./utilities');\n\n// constants\nvar MAX_UINT = Math.pow(1<<16, 2);\nvar MAX_SAFE_HIGH_BITS = Math.pow(2, 53 - 32);\n\nvar types = module.exports = {};\ntypes.Type = {};\ntypes.Type.described = function(descriptor, value) { return new DescribedType(descriptor, value); };\n\nfunction registerType(name, options) {\n  types.Type[name] = function(value) { return new ForcedType(name, value); };\n\n  if (typeof options === 'string') { // this is an alias\n    types[name] = types[options];\n    return;\n  }\n\n  if (!types.hasOwnProperty(name)) types[name] = {};\n  if (!!options.encoder) {\n    types[name].encode = options.encoder;\n  } else {\n    // default to first encoding\n    var typeCode = options.encodings[0].code;\n    types[name].encode = function(val, bufb) {\n      bufb.appendUInt8(typeCode);\n      types[typeCode].encode(val, bufb);\n    };\n  }\n\n  if (!options.hasOwnProperty('encodings')) return;\n  options.encodings.forEach(function(encoding) {\n    if (!types.hasOwnProperty(encoding.code)) types[encoding.code] = {};\n    types[encoding.code].decode = encoding.decoder;\n    types[encoding.code].encode = encoding.encoder;\n  });\n}\n\ntypes.registerType = registerType;\n\n/**\n * Encoder methods are used for all examples of that type and are expected to encode to the proper\n * type (e.g. a uint will encode to the fixed-zero-value, the short uint, or the full uint as appropriate).\n *\n * @function encoder\n * @param val               Value to encode (for fixed value encoders (e.g. null) this will be ignored)\n * @param {Builder} buf     Buffer-builder into which to write code and encoded value\n * @param {Codec} [codec]   If needed, the codec to encode other values (e.g. for lists/arrays)\n */\n\n/**\n * Decoder methods decode an incoming buffer into an appropriate concrete JS entity.\n *\n * @function decoder\n * @param {Buffer} buf          Buffer to decode, stripped of prefix code (e.g. 0xA1 0x03 'foo' would\n *                              have the 0xA1 stripped)\n * @param {Codec} [codec]       If needed, the codec to decode sub-values for composite types.\n * @return                      Decoded value\n */\n\n/**\n * Encoder for list types, specified in AMQP 1.0 as:\n *\n <pre>\n                       +----------= count items =----------+\n                       |                                   |\n   n OCTETs   n OCTETs |                                   |\n +----------+----------+--------------+------------+-------+\n |   size   |  count   |      ...    /|    item    |\\ ...  |\n +----------+----------+------------/ +------------+ \\-----+\n                                   / /              \\ \\\n                                  / /                \\ \\\n                                 / /                  \\ \\\n                                +-------------+----------+\n                                | constructor |   data   |\n                                +-------------+----------+\n\n              Subcategory     n\n              =================\n              0xC             1\n              0xD             4\n </pre>\n *\n * @param {Array} val           Value to encode.\n * @param {Builder} bufb        Buffer-encoder to write encoded list into.\n * @param {Codec} codec         Codec to use for encoding list entries.\n * @param {Number} [width]      Should be 1 or 4.  If given, encoder assumes code already written,\n *                              and will ensure array is encoded to the given byte-width type. Useful for arrays.\n * @private\n */\nfunction listBuilder(list, bufb, codec, width) {\n  if (!Array.isArray(list)) {\n    throw new errors.EncodingError(list, 'Unsure how to encode non-array as list');\n  }\n\n  if (!width && list.length === 0) {\n    bufb.appendUInt8(0x45);\n    return;\n  }\n\n  // Encode all elements into a temp buffer to allow us to front-load appropriate size and count.\n  var tempBuilder = new Builder();\n  var _len = list.length;\n  for (var _i = 0; _i < _len; ++_i) codec.encode(list[_i], tempBuilder);\n  var tempBuffer = tempBuilder.get();\n\n  // Code, size, length, data\n  if (width === 1 || (tempBuffer.length < 0xFF && list.length < 0xFF && width !== 4)) {\n    // list8\n    if (!width) bufb.appendUInt8(0xC0);\n    bufb.appendUInt8(tempBuffer.length + 1);\n    bufb.appendUInt8(list.length);\n  } else {\n    // list32\n    if (!width) bufb.appendUInt8(0xD0);\n    bufb.appendUInt32BE(tempBuffer.length + 4);\n    bufb.appendUInt32BE(list.length);\n  }\n\n  bufb.appendBuffer(tempBuffer);\n}\n\nfunction listDecoder(width, buffer, codec) {\n  var offset = width * 2;\n  var decoded = codec.decode(buffer, offset);\n  var result = [];\n  while (decoded !== undefined) {\n    result.push(decoded[0]);\n    offset += decoded[1];\n    decoded = codec.decode(buffer, offset);\n  }\n\n  return result;\n}\n\n/**\n *\n * All array encodings consist of a size followed by a count followed by an element constructor\n * followed by <i>count</i> elements of encoded data formatted as required by the element\n * constructor:\n <pre>\n                                             +--= count elements =--+\n                                             |                      |\n   n OCTETs   n OCTETs                       |                      |\n +----------+----------+---------------------+-------+------+-------+\n |   size   |  count   | element-constructor |  ...  | data |  ...  |\n +----------+----------+---------------------+-------+------+-------+\n\n                         Subcategory     n\n                         =================\n                         0xE             1\n                         0xF             4\n </pre>\n *\n * @param {AMQPArray} val       Value to encode.\n * @param {Builder} bufb        Buffer-encoder to encode array into.\n * @param {Codec} codec         Codec to use for encoding array values.  Passed into encoder.\n * @param {Number} [width]      Should be 1 or 4.  If given, encoder assumes code already written,\n *                              and will ensure array is encoded to the given byte-width type. Useful for arrays.\n * @private\n */\nfunction arrayBuilder(val, bufb, codec, width) {\n  if (!(val instanceof AMQPArray)) {\n    throw new errors.EncodingError(val, 'Unsure how to encode non-amqp array as array');\n  }\n\n  if (!width && val.array.length === 0) {\n    bufb.appendUInt8(0x40); // null\n    return;\n  }\n\n  if (!types.hasOwnProperty(val.elementType)) {\n    throw new errors.EncodingError(val.elementType, 'invalid element type for AMQPArray');\n  }\n\n  var encoder = types[val.elementType];\n  var _len = val.array.length;\n  var buffers = [];\n  for (var _i = 0; _i < _len; ++_i) {\n    var tempBufb = new Builder();\n    encoder.encode(val.array[_i], tempBufb, codec);\n\n    // NOTE: massive hack around the fact that we haven't split the code\n    // from encoding.\n    if (typeof val.elementType === 'string') {\n      if (_i > 0) {\n        var tempBuf = new Buffer(tempBufb.length - 1);\n        tempBufb.copy(tempBuf, 0, 1, tempBufb.length);\n        buffers.push(tempBuf);\n      } else {\n        buffers.push(tempBufb.get());\n      }\n    } else {\n      buffers.push(tempBufb.get());\n    }\n  }\n  var arrayBytes = Buffer.concat(buffers);\n  var length = 0;\n  if (width === 1 || (width !== 4 && arrayBytes.length < 0xFF && val.array.length < 0xFF)) {\n    if (!width) bufb.appendUInt8(0xE0);\n    length = arrayBytes.length + 1;\n    if (typeof val.elementType === 'number') length += 1;\n    bufb.appendUInt8(length); // buffer + count + constructor\n    bufb.appendUInt8(val.array.length);\n  } else {\n    if (!width) bufb.appendUInt8(0xF0);\n    length = arrayBytes.length + 4;\n    if (typeof val.elementType === 'number') length += 1;\n    bufb.appendUInt32BE(length); // buffer + count + constructor\n    bufb.appendUInt32BE(val.array.length);\n  }\n\n  if (typeof val.elementType === 'number') bufb.appendUInt8(val.elementType);\n  bufb.appendBuffer(arrayBytes);\n}\n\nfunction arrayDecoder(width, buffer, codec) {\n  var count = (width === 1) ? buffer.readUInt8(1) : buffer.readUInt32BE(width);\n  var offset = width * 2;\n  var elementType = buffer.readUInt8(offset++);\n  if (!types.hasOwnProperty(elementType)) {\n    throw new errors.MalformedPayloadError('Unknown array element type ' + elementType.toString(16));\n  }\n\n  var result = [];\n  for (var idx = 0; idx < count; ++idx) {\n    var decoded = codec.decode(buffer, offset, elementType);\n    if (!decoded) {\n      throw new errors.MalformedPayloadError('Unable to decode value of ' + elementType.toString(16) + ' from buffer ' + buffer.toString('hex') + ' at index ' + idx + ' of array');\n    }\n\n    result.push(decoded[0]);\n    offset += decoded[1];\n  }\n\n  return result;\n}\n\n/**\n * A map is encoded as a compound value where the constituent elements form alternating key value pairs.\n *\n <pre>\n  item 0   item 1      item n-1    item n\n +-------+-------+----+---------+---------+\n | key 1 | val 1 | .. | key n/2 | val n/2 |\n +-------+-------+----+---------+---------+\n </pre>\n *\n * Map encodings must contain an even number of items (i.e. an equal number of keys and\n * values). A map in which there exist two identical key values is invalid. Unless known to\n * be otherwise, maps must be considered to be ordered - that is the order of the key-value\n * pairs is semantically important and two maps which are different only in the order in\n * which their key-value pairs are encoded are not equal.\n *\n * @param {Object} val          Value to encode.\n * @param {Builder} bufb        Buffer-builder to encode map into.\n * @param {Codec} codec         Codec to use for encoding keys and values.\n * @param {Number} [width]      Should be 1 or 4.  If given, encoder assumes code already written,\n *                              and will ensure array is encoded to the given byte-width type. Useful for arrays.\n * @private\n */\nfunction mapBuilder(map, bufb, codec, width) {\n  if (typeof map !== 'object') {\n    throw new errors.EncodingError(map, 'Unsure how to encode non-object as map');\n  }\n\n  if (Array.isArray(map)) {\n    throw new errors.EncodingError(map, 'Unsure how to encode array as map');\n  }\n\n  var keys = Object.keys(map);\n  if (!width && keys.length === 0) {\n    bufb.appendUInt8(0xC1);\n    bufb.appendUInt8(1);\n    bufb.appendUInt8(0);\n    return;\n  }\n\n  // Encode all elements into a temp buffer to allow us to front-load appropriate size and count.\n  var tempBuilder = new Builder();\n  var _len = keys.length;\n  for (var _i = 0; _i < _len; ++_i) {\n    codec.encode(keys[_i], tempBuilder);\n    codec.encode(map[keys[_i]], tempBuilder);\n  }\n  var tempBuffer = tempBuilder.get();\n\n  // Code, size, length, data\n  if (width === 1 || (width !== 4 && tempBuffer.length < 0xFF)) {\n    // map8\n    if (!width) bufb.appendUInt8(0xC1);\n    bufb.appendUInt8(tempBuffer.length + 1);\n    bufb.appendUInt8(keys.length * 2);\n  } else {\n    // map32\n    if (!width) bufb.appendUInt8(0xD1);\n    bufb.appendUInt32BE(tempBuffer.length + 4);\n    bufb.appendUInt32BE(keys.length * 2);\n  }\n\n  bufb.appendBuffer(tempBuffer);\n}\n\nfunction mapBuilderForKeyType(keyType) {\n  return function mapBuilder(map, bufb, codec, width) {\n    if (typeof map !== 'object') {\n      throw new errors.EncodingError(map, 'Unsure how to encode non-object as map');\n    }\n\n    if (Array.isArray(map)) {\n      throw new errors.EncodingError(map, 'Unsure how to encode array as map');\n    }\n\n    var keys = Object.keys(map);\n    if (!width && keys.length === 0) {\n      bufb.appendUInt8(0xC1);\n      bufb.appendUInt8(1);\n      bufb.appendUInt8(0);\n      return;\n    }\n\n    // Encode all elements into a temp buffer to allow us to front-load appropriate size and count.\n    var tempBuilder = new Builder();\n    var _len = keys.length;\n    for (var _i = 0; _i < _len; ++_i) {\n      var key = (!!keyType) ? new ForcedType(keyType, keys[_i]) : keys[_i];\n      codec.encode(key, tempBuilder);\n      codec.encode(map[keys[_i]], tempBuilder);\n    }\n    var tempBuffer = tempBuilder.get();\n\n    // Code, size, length, data\n    if (width === 1 || (width !== 4 && tempBuffer.length < 0xFF)) {\n      // map8\n      if (!width) bufb.appendUInt8(0xC1);\n      bufb.appendUInt8(tempBuffer.length + 1);\n      bufb.appendUInt8(keys.length * 2);\n    } else {\n      // map32\n      if (!width) bufb.appendUInt8(0xD1);\n      bufb.appendUInt32BE(tempBuffer.length + 4);\n      bufb.appendUInt32BE(keys.length * 2);\n    }\n\n    bufb.appendBuffer(tempBuffer);\n  };\n}\n\nfunction mapDecoder(countSize, buffer, codec) {\n  var offset = countSize * 2;\n  var decodedKey = codec.decode(buffer, offset);\n  var decodedVal;\n  var result = {};\n  while (decodedKey !== undefined) {\n    offset += decodedKey[1];\n    decodedVal = codec.decode(buffer, offset);\n\n    if (decodedVal !== undefined) {\n      result[decodedKey[0]] = decodedVal[0];\n      offset += decodedVal[1];\n      decodedKey = codec.decode(buffer, offset);\n    }\n  }\n\n  return result;\n}\n\nfunction encoding(code, options) {\n  options = options || {};\n  var encoder = options.encoder || function() { throw new errors.NotImplementedError(code); },\n      decoder = options.decoder || function() { throw new errors.NotImplementedError(code); };\n\n  return Object.create(Object.prototype, {\n    code: { value: code, configurable: false, writable: false },\n    encoder: { value: encoder, configurable: false, writable: false },\n    decoder: { value: decoder, configurable: false, writable: false },\n  });\n}\n\nfunction bufferOperations(typeName) {\n  return {\n    encoder: function(val, bufb) { bufb['append' + typeName](val); },\n    decoder: function(buf) { return buf['read' + typeName](0); }\n  };\n}\n\nfunction constantValue(value) {\n  return {\n    encoder: function(val, bufb) { },\n    decoder: function(buf) { return value; }\n  };\n}\n\nregisterType('null', { encodings: [ encoding(0x40, constantValue(null)) ] });\nregisterType('boolean', {\n  encoder: function(val, bufb) { bufb.appendUInt8(val ? 0x41 : 0x42); },\n  encodings: [\n    encoding(0x41, constantValue(true)),\n    encoding(0x42, constantValue(false)),\n    encoding(0x56, {\n      encoder: function(val, bufb) { bufb.appendUInt8(val ? 0x01 : 0x00); },\n      decoder: function(buf) { return buf[0] ? true : false; }\n    })\n  ]\n});\n\nregisterType('ubyte', { encodings: [ encoding(0x50, bufferOperations('UInt8')) ] });\nregisterType('ushort', { encodings: [ encoding(0x60, bufferOperations('UInt16BE')) ] });\nregisterType('uint', {\n  encoder: function(val, bufb) {\n    var code;\n    if (val === 0) {\n      code = 0x43;\n    } else if (val < 0xFF) {\n      code = 0x52;\n    } else {\n      code = 0x70;\n    }\n\n    bufb.appendUInt8(code);\n    types[code].encode(val, bufb);\n  },\n  encodings: [\n    encoding(0x70, bufferOperations('UInt32BE')),\n    encoding(0x52, bufferOperations('UInt8')),\n    encoding(0x43, constantValue(0))\n  ]\n});\n\nregisterType('ulong', {\n  encoder: function(val, bufb) {\n    var code = 0x80;\n    if (val instanceof Int64 || val > 0xFF) {\n      var check = (val instanceof Int64) ? val.toNumber(true) : val;\n      if (check === 0) {\n        code = 0x44;\n      } else if (check <= 0xFF) {\n        code = 0x53;\n      }\n    } else if (val > 0 && val <= 0xFF) {\n      code = 0x53;\n    } else if (val === 0) {\n      code = 0x44;\n    } else {\n      throw new errors.EncodingError(val, 'Invalid encoding type for ulong value');\n    }\n\n    bufb.appendUInt8(code);\n    types[code].encode(val, bufb);\n  },\n  encodings: [\n    encoding(0x53, bufferOperations('UInt8')),\n    encoding(0x44, constantValue(0)),\n    encoding(0x80, {\n      encoder: function(val, bufb) {\n        if (val instanceof Int64) return bufb.appendBuffer(val.toBuffer(true));\n        if (val instanceof Buffer) return bufb.appendBuffer(val);\n        if (typeof val !== 'number' || !(val instanceof Number)) val = Number(val);\n        if (!Number.isFinite(val)) {\n          throw new errors.EncodingError(val, 'invalid number');\n        }\n\n        var high = val / MAX_UINT;\n        var low = val % MAX_UINT;\n        bufb.appendUInt32BE(high);\n        bufb.appendUInt32BE(low);\n      },\n      decoder: function(buf) {\n        var high = buf.readUInt32BE(0);\n        var low = buf.readUInt32BE(4);\n        if (high < MAX_SAFE_HIGH_BITS)\n          return ((high >>> 0) * MAX_UINT) + (low >>> 0);\n\n        var int64 = new Int64(buf);\n        var number = int64.toNumber(false);\n        if (isFinite(number)) return number;\n        return int64;\n      }\n    })\n  ]\n});\n\nregisterType('byte', { encodings: [ encoding(0x51, bufferOperations('Int8')) ] });\nregisterType('short', { encodings: [ encoding(0x61, bufferOperations('Int16BE')) ] });\nregisterType('int', {\n  encoder: function(val, bufb) {\n    var code = (Math.abs(val) < 0x80) ? 0x54 : 0x71;\n    bufb.appendUInt8(code);\n    types[code].encode(val, bufb);\n  },\n  encodings: [\n    encoding(0x71, bufferOperations('Int32BE')),\n    encoding(0x54, bufferOperations('Int8'))\n  ]\n});\n\nregisterType('long', {\n  encoder: function(val, bufb) {\n    var check = (val instanceof Int64) ? val.toNumber(true) : val;\n    var code = (Math.abs(check) < 0x80) ? 0x55 : 0x81;\n    bufb.appendUInt8(code);\n    types[code].encode(val, bufb); // @todo Deal with Math.abs(val) < 0x7F cases\n  },\n  encodings: [\n    encoding(0x55, bufferOperations('Int8')),\n    encoding(0x81, {\n      encoder: function(val, bufb) {\n        if (val instanceof Int64) return bufb.appendBuffer(val.toBuffer(true));\n        if (val instanceof Buffer) return bufb.appendBuffer(val);\n        if (typeof val !== 'number' || !(val instanceof Number)) val = Number(val);\n        if (!Number.isFinite(val)) {\n          throw new errors.EncodingError(val, 'invalid number');\n        }\n\n        var abs = Math.abs(val);\n        var high = abs / MAX_UINT;\n        var low = abs % MAX_UINT;\n        if (val > 0) {\n          bufb.appendInt32BE(high);\n          bufb.appendUInt32BE(low);\n        } else {\n          // need to write to a buffer in order to calculate the 2s complement\n          var data = new Buffer(8),\n              carry = 1, current = low;\n          for (var i = 7; i >= 0; i--) {\n            var value = ((current & 0xff) ^ 0xff) + carry;\n            data[i] = value & 0xff;\n            current = (i === 4) ? high : current >>> 8;\n            carry = value >> 8;\n          }\n\n          bufb.appendBuffer(data);\n        }\n      },\n      decoder: function(buf) {\n        var high = buf.readUInt32BE(0);\n        var low = buf.readUInt32BE(4);\n        if (high < MAX_SAFE_HIGH_BITS && high > -MAX_SAFE_HIGH_BITS)\n          return high * MAX_UINT + (low >>> 0);\n\n        var int64 = new Int64(buf);\n        var number = int64.toNumber(false);\n        if (isFinite(number)) return number;\n        return int64;\n      }\n    })\n  ]\n});\n\nregisterType('float', { encodings: [ encoding(0x72, bufferOperations('FloatBE')) ] });\nregisterType('double', { encodings: [ encoding(0x82, bufferOperations('DoubleBE')) ] });\nregisterType('decimal32', { encodings: [ encoding(0x74) ] });\nregisterType('decimal64', { encodings: [ encoding(0x84) ] });\nregisterType('decimal128', { encodings: [ encoding(0x94) ] });\n\nregisterType('char', {\n  encodings: [\n    encoding(0x73, {\n      encoder: function(val, bufb) {\n        bufb.appendUInt8(0x73);\n        bufb.appendUInt32BE(val.charCodeAt(0));\n      },\n      decoder: function(buf) {\n        // @todo: this will surely break on something in the future, but in order\n        //        to maintain our desire to not depend on any native modules it may\n        //        be the best we can do for the moment.\n        return String.fromCharCode(buf.readUInt32BE(0));\n      }\n    })\n  ]\n});\n\nregisterType('timestamp', {\n  encodings: [\n    encoding(0x83, {\n      encoder: function(val, bufb) {\n        if (val instanceof Int64) {\n          bufb.appendBuffer(val.toBuffer(true));\n        } else if (val instanceof Date) {\n          bufb.appendBuffer(new Int64(val.getTime()).toBuffer(true));\n        } else if (typeof val === 'number') {\n          bufb.appendBuffer(new Int64(val).toBuffer(true));\n        } else {\n          throw new errors.EncodingError(val, 'Invalid encoding type for 64-bit value');\n        }\n      },\n      decoder: function(buf) {\n        var tmp = new Int64(buf);\n        return new Date(tmp.toNumber(false));\n\n        // @todo: the above conversion is potentially imprecise. We used to\n        //        simply run the following line, giving a user access to the\n        //        exact value. In the future we should allow users to opt-out\n        //        of the above convenience.\n        // return new Int64(buf);\n      }\n    })\n  ]\n});\n\nregisterType('uuid', {\n  encodings: [\n    encoding(0x98, {\n      encoder: function(val, bufb) { bufb.appendBuffer(new Buffer(u.parseUuid(val))); },\n      decoder: function(buf) { return u.unparseUuid(buf); }\n    })\n  ]\n});\n\nregisterType('binary', {\n  encoder: function(val, bufb) {\n    val = (val instanceof Buffer) ? val : new Buffer(val);\n    var code = (val.length <= 0xFF) ? 0xA0 : 0xB0;\n    bufb.appendUInt8(code);\n    types[code].encode(val, bufb);\n  },\n  encodings: [\n    encoding(0xa0, {\n      encoder: function(val, bufb) {\n        bufb.appendUInt8(val.length);\n        bufb.appendBuffer(val);\n      },\n      decoder: function(buf) { return buf.slice(1); }\n    }),\n    encoding(0xb0, {\n      encoder: function(val, bufb) {\n        bufb.appendUInt32BE(val.length);\n        bufb.appendBuffer(val);\n      },\n      decoder: function(buf) { return buf.slice(4); }\n    })\n  ]\n});\n\nregisterType('string', {\n  encoder: function(val, bufb) {\n    var encoded = new Buffer(val, 'utf8');\n    var code = (encoded.length <= 0xFF) ? 0xA1 : 0xB1;\n\n    bufb.appendUInt8(code);\n    types[code].encode(encoded, bufb);\n  },\n  encodings: [\n    encoding(0xa1, {\n      encoder: function(val, bufb) {\n        var encoded = new Buffer(val, 'utf8');\n        bufb.appendUInt8(encoded.length);\n        bufb.appendBuffer(encoded);\n      },\n      decoder: function(buf) {\n        if (buf[0] === 0) return '';\n        return buf.slice(1).toString('utf8');\n      }\n    }),\n    encoding(0xb1, {\n      encoder: function(val, bufb) {\n        var encoded = new Buffer(val, 'utf8');\n        bufb.appendUInt32BE(encoded.length);\n        bufb.appendBuffer(encoded);\n      },\n      decoder: function(buf) {\n        var size = buf.readUInt32BE(0);\n        if (size === 0) return '';\n        return buf.slice(4).toString('utf8');\n      }\n    })\n  ]\n});\n\nregisterType('symbol', {\n  encoder: function(val, bufb) {\n    var encoded = new Buffer(typeof val === 'object' ? val.value : val, 'ascii');\n    var code = (encoded.length <= 0xFF) ? 0xA3 : 0xB3;\n    bufb.appendUInt8(code);\n    types[code].encode(encoded, bufb);\n  },\n  encodings: [\n    encoding(0xa3, {\n      encoder: function(val, bufb) {\n        var encoded = (val instanceof Buffer) ? val : new Buffer(val, 'ascii');\n        bufb.appendUInt8(encoded.length);\n        bufb.appendBuffer(encoded);\n      },\n      decoder: function(buf) { return buf.slice(1).toString('ascii'); }\n    }),\n    encoding(0xb3, {\n      encoder: function(val, bufb) {\n        var encoded = (val instanceof Buffer) ? val : new Buffer(val, 'ascii');\n        bufb.appendUInt32BE(encoded.length);\n        bufb.appendBuffer(encoded);\n      },\n      decoder: function(buf) { return buf.slice(4).toString('ascii'); }\n    })\n  ]\n});\n\nregisterType('list', {\n  encoder: listBuilder,\n  encodings: [\n    encoding(0x45, {\n      encoder: function(val, bufb, codec) {},\n      decoder: function(buf) { return []; }\n    }),\n    encoding(0xc0, {\n      encoder: function(val, bufb, codec) { listBuilder(val, bufb, codec, 1); },\n      decoder: function(buf, codec) { return listDecoder(1, buf, codec); }\n    }),\n    encoding(0xd0, {\n      encoder: function(val, bufb, codec) { listBuilder(val, bufb, codec, 4); },\n      decoder: function(buf, codec) { return listDecoder(4, buf, codec); }\n    })\n  ]\n});\n\nregisterType('map', {\n  encoder: mapBuilder,\n  encodings: [\n    encoding(0xc1, {\n      encoder: function(val, bufb, codec) { mapBuilder(val, bufb, codec, 1); },\n      decoder: function(buf, codec) { return mapDecoder(1, buf, codec); }\n    }),\n    encoding(0xd1, {\n      encoder: function(val, bufb, codec) { mapBuilder(val, bufb, codec, 4); },\n      decoder: function(buf, codec) { return mapDecoder(4, buf, codec); }\n    })\n  ]\n});\n\nregisterType('array', {\n  encoder: arrayBuilder,\n  encodings: [\n    encoding(0xe0, {\n      encoder: function(val, bufb, codec) { arrayBuilder(val, bufb, codec, 1); },\n      decoder: function(buf, codec) { return arrayDecoder(1, buf, codec); }\n    }),\n    encoding(0xf0, {\n      encoder: function(val, bufb, codec) { arrayBuilder(val, bufb, codec, 4); },\n      decoder: function(buf, codec) { return arrayDecoder(4, buf, codec); }\n    })\n  ]\n});\n\nregisterType('error', {\n  encoder: function(value, bufb, codec) {\n    var error = u.isObject(value) ?\n      new AMQPError(value) : new AMQPError({ condition: value });\n    codec.encode(error, bufb);\n  }\n});\n\n// aliases\nregisterType('fields', { encoder: mapBuilderForKeyType('symbol') });\nregisterType('seconds', 'uint');\nregisterType('milliseconds', 'uint');\nregisterType('sequence-no', 'uint');\nregisterType('transfer-number', 'uint');\nregisterType('delivery-number', 'uint');\nregisterType('delivery-tag', 'binary');\nregisterType('handle', 'uint');\nregisterType('message-format', 'uint');\nregisterType('address', 'string');\nregisterType('ietf-language-tag', 'symbol');\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/terminus.js":"'use strict';\nvar defineComposite = require('./composite_type').defineComposite,\n    errors = require('../errors');\n\nvar Terminus = module.exports = {};\n\nfunction terminusDurability(value) {\n  if (typeof value === 'number' || value instanceof Number)\n    return value;\n\n  if (value === 'configuration') return 1;\n  else if (value === 'unsettled-state') return 2;\n  else return 0;\n}\n\nvar TerminusExpiryPolicies = [ 'link-detach', 'session-end', 'connection-close', 'never' ];\nfunction terminusExpiryPolicy(value) {\n  if (TerminusExpiryPolicies.indexOf(value) === -1)\n    throw new errors.EncodingError(value, 'invalid terminus expiry policy');\n  return value;\n}\n\nfunction distributionMode(value) {\n  if (value !== 'move' && value !== 'copy')\n    throw new errors.EncodingError(value, 'invalid distribution mode');\n  return value;\n}\n\nTerminus.Source = defineComposite({\n  name: 'source', code: 0x28,\n  fields: [\n    { name: 'address', type: 'address' },\n    { name: 'durable', type: 'uint', requires: terminusDurability, default: 'none' },\n    { name: 'expiryPolicy', type: 'symbol', requires: terminusExpiryPolicy, default: 'session-end' },\n    { name: 'timeout', type: 'seconds', default: 0 },\n    { name: 'dynamic', type: 'boolean', default: false },\n    { name: 'dynamicNodeProperties', type: 'fields', default: {} }, // @spec type: `node-properties` => `fields`\n    { name: 'distributionMode', type: 'symbol', requires: distributionMode },\n    { name: 'filter', type: 'fields', default: {} },  // @spec type: `filter-set` => `fields`\n    { name: 'defaultOutcome', type: '*' },  // @spec type: `*`, requires: `outcome` => `deliveryState`\n    { name: 'outcomes', type: 'symbol', multiple: true },\n    { name: 'capabilities', type: 'symbol', multiple: true }\n  ]\n});\n\nTerminus.Target = defineComposite({\n  name: 'target', code: 0x29,\n  fields: [\n    { name: 'address', type: 'address' },\n    { name: 'durable', type: 'uint', requires: terminusDurability, default: 'none' },\n    { name: 'expiryPolicy', type: 'symbol', requires: terminusExpiryPolicy, default: 'session-end' },\n    { name: 'timeout', type: 'seconds', default: 0 },\n    { name: 'dynamic', type: 'boolean', default: false },\n    { name: 'dynamicNodeProperties', type: 'fields', default: {} }, // @spec type: `node-properties` => `fields`\n    { name: 'capabilities', type: 'symbol', multiple: true }\n  ]\n});\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/transport/index.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar AbstractTransport = require('./abstract_transport.js');\nvar NetTransport = require('./net_transport.js');\nvar TlsTransport = require('./tls_transport.js');\n\nfunction TransportProvider() {\n  this._transportFactories = {};\n}\n\nvar verifyImplementation = function (transportFactory) {\n  // NOTE: if we only cared about internal modules, 'instanceof' would work, but\n  // since we're \"duck typing\" transports to avoid circular dependencies, we have to\n  // verify the transport prototype differently.\n\n  var transport = transportFactory();\n  for(var member in AbstractTransport.prototype) {\n    if (AbstractTransport.prototype.hasOwnProperty(member))\n      if (typeof AbstractTransport.prototype[member] !== typeof transport[member]) {\n        throw new Error('transport should implement the \\'' + member + '\\' method.');\n      }\n  }\n\n  if (!(transport instanceof EventEmitter))\n  {\n    throw new Error('transport should inherit from EventEmitter');\n  }\n};\n\nTransportProvider.prototype.registerTransport = function(protocol, transportFactory) {\n  verifyImplementation(transportFactory);\n  this._transportFactories[protocol] = transportFactory;\n};\n\nTransportProvider.prototype.getTransportFor = function(protocol) {\n  if (!this._transportFactories.hasOwnProperty(protocol))\n    throw new Error('invalid protocol: ', protocol);\n\n  return this._transportFactories[protocol]();\n};\n\nmodule.exports = (function() {\n  var provider = new TransportProvider();\n\n  // pre-register our \"known\" transports\n  NetTransport.register(provider);\n  TlsTransport.register(provider);\n  return provider;\n})();\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/transport/abstract_transport.js":"'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar errors = require('../errors');\n\nvar throwBecauseAbstract = function(methodName) {\n  throw new errors.TransportError('Cannot use AbstractTransport. Subclass must implement ' + methodName);\n};\n\nvar AbstractTransport = function () {\n  if (this.constructor === AbstractTransport) {\n    throwBecauseAbstract('constructor');\n  }\n\n  EventEmitter.call(this);\n};\n\nutil.inherits(AbstractTransport, EventEmitter);\n\nAbstractTransport.register = function (client) {\n  throwBecauseAbstract('register');\n};\n\nAbstractTransport.prototype.connect = function (address) {\n  throwBecauseAbstract('connect');\n};\n\nAbstractTransport.prototype.write = function (data, callback) {\n  throwBecauseAbstract('write');\n};\n\nAbstractTransport.prototype.end = function() {\n  throwBecauseAbstract('end');\n};\n\nAbstractTransport.prototype.destroy = function() {\n  throwBecauseAbstract('destroy');\n};\n\nmodule.exports = AbstractTransport;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/transport/net_transport.js":"'use strict';\n\nvar AbstractTransport = require('./abstract_transport.js'),\n    util = require('util'),\n    net = require('net'),\n    debug = require('debug')('amqp10:transport:net'),\n    errors = require('../errors');\n\nvar NetTransport = function () {\n  AbstractTransport.call(this);\n  this._socket = null;\n};\n\nutil.inherits(NetTransport, AbstractTransport);\n\nNetTransport.register = function (transportProvider) {\n  transportProvider.registerTransport('amqp', function() { return new NetTransport(); });\n};\n\nNetTransport.prototype.connect = function (address) {\n  debug('Connecting to ' + address.host + ':' + address.port + ' via straight-up sockets');\n  this._socket = net.connect({ port: address.port, host: address.host });\n\n  var self = this;\n  this._socket.on('connect', function() { self.emit('connect'); });\n  this._socket.on('data', function(data) { self.emit('data', data); });\n  this._socket.on('error', function(err) { self.emit('error', err); });\n  this._socket.on('end', function() { self.emit('end'); });\n};\n\nNetTransport.prototype.write = function (data, callback) {\n  if (!this._socket) {\n    throw new errors.TransportError('Socket not connected');\n  }\n\n  this._socket.write(data, callback);\n};\n\nNetTransport.prototype.end = function() {\n  if (!this._socket) {\n    throw new errors.TransportError('Socket not connected');\n  }\n\n  this._socket.end();\n};\n\nNetTransport.prototype.destroy = function() {\n  if (this._socket) {\n    this._socket.destroy();\n    this._socket = null;\n  }\n\n  this.removeAllListeners();\n};\n\nmodule.exports = NetTransport;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/transport/tls_transport.js":"'use strict';\n\nvar AbstractTransport = require('./abstract_transport.js'),\n    util = require('util'),\n    tls = require('tls'),\n    debug = require('debug')('amqp10:transport:tls'),\n    errors = require('../errors');\n\nvar TlsTransport = function() {\n  AbstractTransport.call(this);\n  this._socket = null;\n};\n\nutil.inherits(TlsTransport, AbstractTransport);\n\nTlsTransport.register = function (transportProvider) {\n  transportProvider.registerTransport('amqps', function () {return new TlsTransport(); });\n};\n\nTlsTransport.prototype.connect = function (address, sslOpts) {\n  var sslOptions = sslOpts || {};\n  sslOptions.port = address.port;\n  sslOptions.host = address.host;\n  this._socket = tls.connect(sslOptions);\n  debug('Connecting to ' + address.host + ':' + address.port + ' via TLS');\n\n  var self = this;\n  this._socket.on('secureConnect', function() { self.emit('connect'); });\n  this._socket.on('data', function(data) { self.emit('data', data); });\n  this._socket.on('error', function(err) { self.emit('error', err); });\n  this._socket.on('end', function() { self.emit('end'); });\n};\n\nTlsTransport.prototype.write = function (data, callback) {\n  if (!this._socket) {\n    throw new errors.TransportError('Socket not connected');\n  }\n\n  this._socket.write(data, callback);\n};\n\nTlsTransport.prototype.end = function() {\n  if (!this._socket) {\n    throw new errors.TransportError('Socket not connected');\n  }\n\n  this._socket.end();\n};\n\nTlsTransport.prototype.destroy = function() {\n  if (this._socket) {\n    this._socket.destroy();\n    this._socket = null;\n  }\n\n  this.removeAllListeners();\n};\n\nmodule.exports = TlsTransport;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/sasl.js":"'use strict';\n\nvar debug = require('debug')('amqp10:sasl'),\n    Builder = require('buffer-builder'),\n\n    constants = require('./constants'),\n    frames = require('./frames'),\n    errors = require('./errors'),\n    u = require('./utilities'),\n\n    Connection = require('./connection');\n\nvar saslMechanism = {\n  PLAIN: 'PLAIN',\n  ANONYMOUS: 'ANONYMOUS',\n  NONE: 'NONE'\n};\n\n/**\n * Currently, only supports SASL ANONYMOUS or PLAIN\n *\n * @constructor\n */\nfunction Sasl(mechanism) {\n  if (mechanism && !u.includes(saslMechanism, mechanism)) {\n    throw new errors.NotImplementedError(\n      'Only SASL PLAIN and ANONYMOUS are supported.');\n  }\n  this.mechanism = mechanism;\n  this.receivedHeader = false;\n}\n\nSasl.Mechanism = saslMechanism;\n\nSasl.prototype.negotiate = function(connection, credentials, done) {\n  this.connection = connection;\n  this.credentials = credentials;\n  if (this.credentials.user && this.credentials.pass && !this.mechanism) {\n    this.mechanism = Sasl.Mechanism.PLAIN;\n  }\n  this.callback = done;\n  var self = this;\n  this._processFrameEH = function(frame) { self._processFrame(frame); };\n  this.connection.on(Connection.FrameReceived, this._processFrameEH);\n  this._sendHeader();\n};\n\nSasl.prototype._sendHeader = function() {\n  this.connection.sendHeader(constants.saslVersion);\n};\n\nSasl.prototype.headerReceived = function(header) {\n  debug('Server SASL Version: ' + header.toString('hex') + ' vs ' + constants.saslVersion.toString('hex'));\n  if (u.bufferEquals(header, constants.saslVersion)) {\n    this.receivedHeader = true;\n    // Wait for mechanisms\n  } else {\n    this.callback(new errors.MalformedHeaderError('Invalid SASL Header ' + header.toString('hex')));\n  }\n};\n\nSasl.prototype._processFrame = function(frame) {\n  if (frame instanceof frames.SaslMechanismsFrame) {\n    var buf = new Builder();\n    var mechanism = this.mechanism;\n    var mechanisms = Array.isArray(frame.saslServerMechanisms) ?\n      frame.saslServerMechanisms.map(function(m) { return m.value; }) : frame.saslServerMechanisms;\n    if (!u.includes(mechanisms, mechanism)) {\n      this.callback(new errors.AuthenticationError(\n        'SASL ' + mechanism + ' not supported by remote.'));\n    }\n    if (mechanism === Sasl.Mechanism.PLAIN) {\n      debug('Sending ' + this.credentials.user + ':' + this.credentials.pass);\n      buf.appendUInt8(0); // <null>\n      buf.appendString(this.credentials.user);\n      buf.appendUInt8(0); // <null>\n      buf.appendString(this.credentials.pass);\n    } else if (mechanism === Sasl.Mechanism.ANONYMOUS) {\n      if (this.credentials.user && this.credentials.pass) {\n        console.warn(\n            'Sasl ANONYMOUS requested, but credentials provided in endpoint URI');\n      }\n      buf.appendUInt8(0); // <null>\n    } else {\n      this.callback(new errors.NotImplementedError(\n          'Only SASL PLAIN and ANONYMOUS are supported.'));\n    }\n    var initFrame = new frames.SaslInitFrame({\n      mechanism: mechanism,\n      initialResponse: buf.get()\n    });\n\n    if (!!this._remoteHostname) initFrame.hostname = this._remoteHostname;\n    this.connection.sendFrame(initFrame);\n  } else if (frame instanceof frames.SaslChallengeFrame) {\n    var responseFrame = new frames.SaslResponseFrame({});\n    this.connection.sendFrame(responseFrame);\n  } else if (frame instanceof frames.SaslOutcomeFrame) {\n    if (frame.code === constants.saslOutcomes.ok) {\n      this.callback();\n    } else {\n      this.callback(new errors.AuthenticationError('SASL Failed: ' + frame.code + ': ' + frame.details));\n    }\n  }\n};\n\n// @todo: Methods for sending init, receiving challenge, sending response, receiving outcome.\n\nmodule.exports = Sasl;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/session.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter,\n    util = require('util'),\n\n    StateMachine = require('stately.js'),\n\n    debug = require('debug')('amqp10:session'),\n\n    frames = require('./frames'),\n    constants = require('./constants'),\n    errors = require('./errors'),\n    u = require('./utilities'),\n\n    Link = require('./link'),\n    SenderLink = require('./sender_link'),\n    ReceiverLink = require('./receiver_link'),\n    Connection = require('./connection');\n\nvar stateMachine = function(session) {\n  return {\n    'UNMAPPED': { sendBegin: 'BEGIN_SENT' },\n    'BEGIN_SENT': { beginReceived: 'MAPPED' },\n    'MAPPED': {\n      sendEnd: 'END_SENT',\n      endReceived: 'END_RCVD'\n    },\n    'END_SENT': { endReceived: 'UNMAPPED' },\n    'DISCARDING': { endReceived: 'UNMAPPED' },\n    'END_RCVD': { sendEnd: 'UNMAPPED' }\n  };\n};\n\n/**\n * A Session is a bidirectional sequential conversation between two containers that provides a\n * grouping for related links. Sessions serve as the context for link communication. Any number\n * of links of any directionality can be <i>attached</i> to a given Session. However, a link\n * may be attached to at most one Session at a time.\n *\n * Session states, from AMQP 1.0 spec:\n *\n <dl>\n <dt>UNMAPPED</dt>\n <dd><p>In the UNMAPPED state, the Session endpoint is not mapped to any incoming or outgoing\n channels on the Connection endpoint. In this state an endpoint cannot send or receive\n frames.</p></dd>\n\n <dt>BEGIN-SENT</dt>\n <dd><p>In the BEGIN-SENT state, the Session endpoint is assigned an outgoing channel number,\n but there is no entry in the incoming channel map. In this state the endpoint may send\n frames but cannot receive them.</p></dd>\n\n <dt>BEGIN-RCVD</dt>\n <dd><p>In the BEGIN-RCVD state, the Session endpoint has an entry in the incoming channel\n map, but has not yet been assigned an outgoing channel number. The endpoint may receive\n frames, but cannot send them.</p></dd>\n\n <dt>MAPPED</dt>\n <dd><p>In the MAPPED state, the Session endpoint has both an outgoing channel number and an\n entry in the incoming channel map. The endpoint may both send and receive\n frames.</p></dd>\n\n <dt>END-SENT</dt>\n <dd><p>In the END-SENT state, the Session endpoint has an entry in the incoming channel map,\n but is no longer assigned an outgoing channel number. The endpoint may receive frames,\n but cannot send them.</p></dd>\n\n <dt>END-RCVD</dt>\n <dd><p>In the END-RCVD state, the Session endpoint is assigned an outgoing channel number,\n but there is no entry in the incoming channel map. The endpoint may send frames, but\n cannot receive them.</p></dd>\n\n <dt>DISCARDING</dt>\n <dd><p>The DISCARDING state is a variant of the END-SENT state where the <code>end</code>\n is triggered by an error. In this case any incoming frames on the session MUST be\n silently discarded until the peer's <code>end</code> frame is received.</p></dd>\n </dl>\n\n <pre>\n                         UNMAPPED< ------------------+\n                            |                        |\n                    +-------+-------+                |\n            S:BEGIN |               | R:BEGIN        |\n                    |               |                |\n                   \\\\|/             \\\\|/               |\n                BEGIN-SENT      BEGIN-RCVD           |\n                    |               |                |\n                    |               |                |\n            R:BEGIN |               | S:BEGIN        |\n                    +-------+-------+                |\n                            |                        |\n                           \\\\|/                       |\n                          MAPPED                     |\n                            |                        |\n              +-------------+-------------+          |\n S:END(error) |       S:END |             | R:END    |\n              |             |             |          |\n             \\\\|/           \\\\|/           \\\\|/         |\n          DISCARDING     END-SENT      END-RCVD      |\n              |             |             |          |\n              |             |             |          |\n        R:END |       R:END |             | S:END    |\n              +-------------+-------------+          |\n                            |                        |\n                            |                        |\n                            +------------------------+\n  </pre>\n *\n * There is no obligation to retain a Session Endpoint when it is in the UNMAPPED state, i.e.\n * the UNMAPPED state is equivalent to a NONEXISTENT state.\n *\n * Note: This implementation *assumes* it is the client, and thus will always be the one BEGIN-ing a Session.\n *\n * @param {Connection} conn     Connection to bind session to.\n * @constructor\n */\nfunction Session(conn) {\n  Session.super_.call(this);\n  this.setMaxListeners(100);\n  this.connection = conn;\n  this.mapped = false;\n  this.remoteChannel = undefined;\n  this._allocatedHandles = {};\n  this._deliveryTag = 1;\n  this._senderLinks = {};\n  this._receiverLinks = {};\n  this._linksByRemoteHandle = {};\n\n  var self = this;\n  this.sm = new StateMachine(stateMachine(this));\n  this.sm.bind(function(event, oldState, newState) {\n    debug('stateChange(' + self.remoteChannel + '):', oldState, '=>', newState, ', reason:', event);\n  });\n}\n\nutil.inherits(Session, EventEmitter);\n\n// Events\nSession.Mapped = 'mapped';\nSession.Unmapped = 'unmapped';\n\n// Since 'error' events are \"special\" in Node (as in halt-the-process special),\n// using a custom event for errors we receive from the other endpoint. Provides\n// received AMQPError as an argument.\nSession.ErrorReceived = 'errorReceived';\n\n// On receipt of a disposition frame, called with the first and last\n// delivery-ids involved, whether they were settled, and the state.\nSession.DispositionReceived = 'disposition';\n\nSession.prototype.begin = function(sessionPolicy) {\n  var sessionParams = u.deepCopy(sessionPolicy.options);\n  u.assertArguments(sessionParams, ['nextOutgoingId', 'incomingWindow', 'outgoingWindow']);\n\n  this.policy = sessionPolicy;\n  this.channel = this.connection.associateSession(this);\n  this._sessionParams = sessionParams;\n  this._initialOutgoingId = sessionParams.nextOutgoingId;\n\n  this.sm.sendBegin();\n  var self = this;\n  this._processFrameEH = function(frame) { self._processFrame(frame); };\n  this.connection.on(Connection.FrameReceived, this._processFrameEH);\n  this.connection.on(Connection.Disconnected, this._resetLinkState);\n\n  var beginFrame = new frames.BeginFrame(this._sessionParams);\n  beginFrame.channel = this.channel;\n  this.connection.sendFrame(beginFrame);\n};\n\nSession.prototype.createLink = function(linkPolicy) {\n  var policy = u.deepCopy(linkPolicy),\n      attachOptions = policy.attach || {};\n\n  attachOptions.handle = this._nextHandle();\n  if (typeof attachOptions.name === 'function')\n    attachOptions.name = attachOptions.name();\n\n  var link;\n  if (attachOptions.role === constants.linkRole.sender) {\n    link = new SenderLink(this, attachOptions.handle, policy);\n    this._senderLinks[attachOptions.name] = link;\n  } else {\n    link = new ReceiverLink(this, attachOptions.handle, policy);\n    this._receiverLinks[attachOptions.name] = link;\n  }\n\n  this._allocatedHandles[attachOptions.handle] = link;\n\n  var self = this;\n  link.on(Link.Detached, function(details) {\n    debug('detached(' + this.name + '): ' + (details ? details.error : 'No details'));\n    if (!this.shouldReattach()) self._removeLink(this);\n  });\n\n  link.on(Link.ErrorReceived, function(err) {\n    self.emit(Session.ErrorReceived, err);\n  });\n\n  if (this.mapped) {\n    // immediately attempt to attach link\n    link.attach();\n  }\n\n  return link;\n};\n\n///\n/// Remove a link from the session\n///\nSession.prototype._removeLink = function(link) {\n  delete this._allocatedHandles[link.handle];\n  if (link instanceof SenderLink) {\n    debug('removing sender link ' + link.name);\n    delete this._senderLinks[link.name];\n  } else {\n    debug('removing receiver link ' + link.name);\n    delete this._receiverLinks[link.name];\n  }\n};\n\nSession.prototype.addWindow = function(windowSize, flowOptions) {\n  var opts = flowOptions || {};\n  this._sessionParams.incomingWindow += windowSize;\n  opts.nextIncomingId = this._sessionParams.nextIncomingId;\n  opts.incomingWindow = this._sessionParams.incomingWindow;\n  opts.nextOutgoingId = this._sessionParams.nextOutgoingId;\n  opts.outgoingWindow = this._sessionParams.outgoingWindow;\n  opts.handle = null;\n  opts.available = null;\n  opts.deliveryCount = null;\n  opts.drain = false;\n\n  var flow = new frames.FlowFrame(opts);\n  flow.channel = this.channel;\n  this.connection.sendFrame(flow);\n};\n\nSession.prototype.detachLink = function(link) {\n  return link.detach();\n};\n\nSession.prototype.end = function() {\n  if (this.remoteChannel !== undefined) {\n    this.sm.sendEnd();\n    this._sendEnd();\n    if (this.sm.getMachineState() === 'UNMAPPED') this._unmap();\n  } else {\n    console.warn('Attempt to end session on channel ' + this.channel + ' before it is mapped.');\n    this._unmap();\n  }\n};\n\nSession.prototype._nextHandle = function() {\n  for (var hid = 0; hid <= this._sessionParams.handleMax; ++hid) {\n    if (this._allocatedHandles[hid] === undefined) {\n      this._allocatedHandles[hid] = true; // Will be replaced by link itself.\n      return hid;\n    }\n  }\n  throw new errors.OverCapacityError('Out of available handles (Max = ' + this._sessionParams.handleMax + ')');\n};\n\nSession.prototype._processFrame = function(frame) {\n  if (frame instanceof frames.BeginFrame && (frame.remoteChannel === this.channel)) {\n    this.sm.beginReceived();\n    this._beginReceived(frame);\n    return;\n  }\n\n  if (frame.channel === undefined || frame.channel !== this.remoteChannel) {\n    debug('invalid frame: ', frame);\n    return;\n  }\n\n  if (frame instanceof frames.EndFrame) return this._processEndFrame(frame);\n  else if (frame instanceof frames.AttachFrame) return this._processAttachFrame(frame);\n  else if (frame instanceof frames.DetachFrame) return this._processDetachFrame(frame);\n  else if (frame instanceof frames.FlowFrame) return this._processFlowFrame(frame);\n  else if (frame instanceof frames.TransferFrame) return this._processTransferFrame(frame);\n  else if (frame instanceof frames.DispositionFrame) return this._processDispositionFrame(frame);\n\n  // else\n  debug('not yet processing frame type: ', frame);\n};\n\nSession.prototype._processEndFrame = function(frame) {\n  this.sm.endReceived();\n  this._endReceived(frame);\n  if (this.sm.getMachineState() !== 'UNMAPPED') {\n    this.sm.sendEnd();\n    this._sendEnd();\n  }\n\n  this._unmap();\n};\n\nSession.prototype._processAttachFrame = function(frame) {\n  var links =\n    (frame.role === constants.linkRole.sender) ? this._receiverLinks : this._senderLinks;\n\n  if (!frame.name || !links[frame.name]) {\n    // @todo: Proper error reporting.  Should we shut down session?\n    console.warn('received Attach for unknown link(', frame.name, '): ');\n    console.log(frame);\n    return;\n  }\n\n  links[frame.name]._attachReceived(frame);\n};\n\nSession.prototype._processDetachFrame = function(frame) {\n  if (frame.handle === undefined || typeof this._linksByRemoteHandle[frame.handle] === 'undefined') {\n    // @todo: Proper error reporting.  Should we shut down session?\n    console.warn('received Detach for unknown link(' + frame.handle + '): ' + JSON.stringify(frame));\n    return;\n  }\n\n  this._linksByRemoteHandle[frame.handle].sm.detachReceived(frame);\n};\n\nSession.prototype._processFlowFrame = function(frame) {\n  this._flowReceived(frame);\n  if (frame.handle !== null) {\n    if (this._linksByRemoteHandle[frame.handle]) {\n      this._linksByRemoteHandle[frame.handle]._flowReceived(frame);\n    }\n  } else {\n    u.values(this._senderLinks).forEach(function (senderLink) {\n      senderLink._flowReceived(frame);\n    });\n  }\n};\n\nSession.prototype._processTransferFrame = function(frame) {\n  if (frame.handle !== null && this._linksByRemoteHandle[frame.handle]) {\n    this._transferReceived(frame);\n    this._linksByRemoteHandle[frame.handle]._messageReceived(frame);\n  } else {\n    console.warn('received Transfer frame for unknown link(' + frame.handle + '): ' + JSON.stringify(frame));\n  }\n};\n\nSession.prototype._beginReceived = function(frame) {\n  this.remoteChannel = frame.channel;\n  this._sessionParams.nextIncomingId = frame.nextOutgoingId;\n  this._sessionParams.remoteIncomingWindow = frame.incomingWindow;\n  this._sessionParams.remoteOutgoingWindow = frame.outgoingWindow;\n  this._sessionParams.handleMax = this._sessionParams.handleMax ?\n      Math.min(this._sessionParams.handleMax, frame.handleMax || constants.defaultHandleMax)\n        : (frame.handleMax || constants.defaultHandleMax);\n  debug('On BEGIN_RCVD, setting params to (' + this._sessionParams.nextIncomingId + ',' + this._sessionParams.remoteIncomingWindow + ',' +\n        this._sessionParams.remoteOutgoingWindow + ',' + this._sessionParams.handleMax + ')');\n  // @todo: Cope with capabilities and properties\n  this.mapped = true;\n  this._deliveryTag = 1;\n  this.emit(Session.Mapped, this);\n\n  // attach all links\n  var attachHandler = function(l) {\n    debug('Attaching link ' + l.name + ':' + l.handle + ' after begin received');\n    if (l.state() !== 'attached' && l.state() !== 'attaching') l.attach();\n  };\n  u.values(this._senderLinks).forEach(attachHandler);\n  u.values(this._receiverLinks).forEach(attachHandler);\n};\n\nSession.prototype._flowReceived = function(frame) {\n  this._sessionParams.nextIncomingId = frame.nextOutgoingId;\n  this._sessionParams.remoteOutgoingWindow = frame.outgoingWindow;\n  if (frame.nextIncomingId === undefined || frame.nextIncomingId === null) {\n    this._sessionParams.remoteIncomingWindow = this._initialOutgoingId +\n            frame.incomingWindow - this._sessionParams.nextOutgoingId;\n    debug('New Incoming Window (no known id): ' + this._sessionParams.remoteIncomingWindow + ' = ' +\n            this._initialOutgoingId + ' + ' + frame.incomingWindow + ' - ' + this._sessionParams.nextOutgoingId);\n  } else {\n    this._sessionParams.remoteIncomingWindow = frame.nextIncomingId +\n            frame.incomingWindow - this._sessionParams.nextOutgoingId;\n    debug('New Incoming Window (known id): ' + this._sessionParams.remoteIncomingWindow + ' = ' +\n        frame.nextIncomingId + ' + ' + frame.incomingWindow + ' - ' + this._sessionParams.nextOutgoingId);\n  }\n};\n\nSession.prototype._transferReceived = function(frame) {\n  this._sessionParams.incomingWindow--;\n  this._sessionParams.remoteOutgoingWindow--;\n\n  if (this._sessionParams.incomingWindow < 0) {\n    // @todo: Shut down session since sender is not respecting window.\n    console.warn('Transfer frame received when no incoming window remaining, should shut down session but for now being tolerant.');\n  }\n\n  if (frame.deliveryId !== undefined && frame.deliveryId !== null) {\n    this._sessionParams.nextIncomingId = frame.deliveryId + 1;\n  }\n};\n\nSession.prototype._endReceived = function(frame) {\n  if (frame.error) {\n    this.emit(Session.ErrorReceived, errors.wrapProtocolError(frame.error));\n  }\n};\n\nSession.prototype._sendEnd = function(frame) {\n  var endFrame = new frames.EndFrame();\n  endFrame.channel = this.channel;\n  this.connection.sendFrame(endFrame);\n};\n\nSession.prototype._unmap = function() {\n  if (this.connection !== undefined && this.channel !== undefined) {\n    this.connection.removeListener(Connection.FrameReceived, this._processFrameEH);\n    this.connection.dissociateSession(this.channel);\n    this.connection = undefined;\n    this.remoteChannel = undefined;\n    this.channel = undefined;\n    this.mapped = false;\n\n    debug('Session unmapped - force-detaching all links.');\n    // force-detach all links (they've already been detached due to unmap, just need to let them know about it)\n    this._resetLinkState();\n    this._linksByRemoteHandle = {};\n    this._allocatedHandles = {};\n\n    this.emit(Session.Unmapped);\n  }\n};\n\nSession.prototype._processDispositionFrame = function(frame) {\n  var disposition = {\n    first: frame.first,\n    last: frame.last || frame.first,\n    settled: frame.settled,\n    state: frame.state\n  };\n\n  var dispositionHandler = function(l) { l._dispositionReceived(disposition); };\n  if (frame.role === constants.linkRole.sender) {\n    u.values(this._receiverLinks).forEach(dispositionHandler);\n  } else {\n    u.values(this._senderLinks).forEach(dispositionHandler);\n  }\n\n  this.emit(Session.DispositionReceived, disposition);\n};\n\n/**\n * INTERNAL\n * Resets the state of all known links for this session.\n */\nSession.prototype._resetLinkState = function() {\n  var forceDetachLink = function(l) { l.forceDetach(); };\n  u.values(this._senderLinks).forEach(forceDetachLink);\n  u.values(this._receiverLinks).forEach(forceDetachLink);\n};\n\nmodule.exports = Session;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/link.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter,\n    Promise = require('bluebird'),\n    util = require('util'),\n\n    StateMachine = require('stately.js'),\n\n    debug = require('debug')('amqp10:link'),\n    u = require('./utilities'),\n    frames = require('./frames'),\n    errors = require('./errors');\n\nvar stateMachine = function(link) {\n  var detachHandler = function(frame) {\n    if (this.getMachineState() === 'ATTACHED') {\n      this.ATTACHED.sendDetach({ closed: frame.closed });\n    }\n\n    link._detached(frame);\n    return this.DETACHED;\n  };\n\n  var states = {\n    'DETACHED': {\n      sendAttach: 'ATTACHING',\n      reattach: 'REATTACHING'\n    },\n    'ATTACHING': { attachReceived: 'ATTACHED' },\n    'REATTACHING': { attachReceived: 'ATTACHED' },\n    'ATTACHED': {\n      sendDetach: function(options) {\n        link._sendDetach(options);\n        return this.DETACHING;\n      },\n    },\n    'DETACHING': { detached: 'DETACHED' }\n  };\n\n  Object.keys(states).forEach(function(s) {\n    states[s].forceDetach = 'DETACHED';\n    states[s].detachReceived = detachHandler;\n  });\n\n  return states;\n};\n\n\n/**\n * @class\n * @extends EventEmitter\n * @fires Link#errorReceived\n * @fires Link#attached\n * @fires Link#detached\n */\nfunction Link(session, handle, linkPolicy) {\n  this.policy = linkPolicy;\n  this.session = session;\n  this.handle = handle;\n  this.remote = { handle: undefined };\n  this.deliveryCount = 0;\n\n  this._onAttach = [];\n  if (this.policy && this.policy.reattach) {\n    this._timeouts = u.generateTimeouts(this.policy.reattach);\n  }\n\n  var self = this;\n  this.sm = new StateMachine(stateMachine(this));\n  this.sm.bind(function(event, oldState, newState) {\n    debug('stateChange(' + self.id + '):', oldState, '=>', newState, ', reason:', event);\n  });\n}\n\nutil.inherits(Link, EventEmitter);\n\n/**\n * Error received event\n *\n * @event Link#errorReceived\n * @param {object} error the received error\n */\nLink.ErrorReceived = 'errorReceived';\n\n/**\n * Attached event\n *\n * @event Link#attached\n */\nLink.Attached = 'attached';\n\n/**\n * Detached event\n *\n * @event Link#detached\n */\nLink.Detached = 'detached';\n\n// public api\n\n/**\n * Detach the link from the session\n *\n * @inner @memberof Link\n * @param {object} [options] detach frame options\n * @return {Promise}\n */\nLink.prototype.detach = function(options) {\n  var self = this;\n  this._timeouts = undefined; // Disable any re-attachment policy.\n  var detachPromise = new Promise(function(resolve, reject) {\n    var onError = function(err) { reject(err); };\n    self.once(Link.ErrorReceived, onError);\n    self.once(Link.Detached, function(info) {\n      self.removeListener(Link.ErrorReceived, onError);\n      if (!!info.error) return reject(info.error);\n      if (!info.closed) {\n        if (!options || options.closed) {\n          return reject('link not closed');\n        }\n      }\n      resolve();\n    });\n  });\n\n  this.sm.sendDetach(options);\n  return detachPromise;\n};\n\n// private api\nLink.prototype.state = function() {\n  return this.sm.getMachineState().toLowerCase();\n};\n\nObject.defineProperty(Link.prototype, 'id', {\n  get: function() { return this.name + ':' + this.handle; }\n});\n\nLink.prototype.attach = function() {\n  this.sm.sendAttach();\n  var attachFrame = new frames.AttachFrame(this.policy.attach);\n  attachFrame.channel = this.session.channel;\n\n  this.name = attachFrame.name;\n  this.role = attachFrame.role;\n  this.linkCredit = 0;\n  this.available = 0;\n  this.drain = false;\n  this.session.connection.sendFrame(attachFrame);\n};\n\n///\n/// Force link state to detached without sending detach message - usually due to forcible disconnect or unmap from above.\n/// Important bit is that this should not trigger auto-reattach behavior as that'll happen with reconnect.\n///\nLink.prototype.forceDetach = function() {\n  var state = this.state();\n  if (state !== 'attached' && state !== 'attaching' && state !== 'reattaching') {\n    return;\n  }\n\n  debug('forceDetach(' + this.id + '): current state:', state);\n  if (!!this._reattachTimer) clearTimeout(this._reattachTimer);\n  this.sm.forceDetach();\n  this.emit(Link.Detached, {\n    closed: true,\n    error: new errors.ProtocolError('amqp:link:detach-forced', 'detach-forced')\n  });\n};\n\nLink.prototype._resolveAttachPromises = function(err, link) {\n  for (var i = 0; i < this._onAttach.length; ++i) {\n    var attachPromise = this._onAttach[i];\n    attachPromise(err, link);\n  }\n\n  this._onAttach = [];\n};\n\nLink.prototype._attachReceived = function(attachFrame) {\n  this.sm.attachReceived();\n\n  // process params.\n  this.remote.handle = attachFrame.handle;\n  this.remote.attach = attachFrame;\n\n  this.session._linksByRemoteHandle[this.remote.handle] = this;\n  debug(this.name + ': attached CH=[' + this.session.channel + '=>' + attachFrame.channel + '], Handle=[' + this.handle + '=>' + attachFrame.handle + ']');\n\n  this.emit(Link.Attached, this);\n  this._resolveAttachPromises(null, this);\n\n  this._checkCredit({ initial: true });\n};\n\n// default implementation does nothing\nLink.prototype._checkCredit = function() {};\nLink.prototype.flow = function(options) {\n  options = options || {};\n  var flowOptions = u.defaults(options, {\n    channel: this.session.channel,\n    handle: this.handle,\n    linkCredit: this.linkCredit,\n    nextIncomingId: this.session._sessionParams.nextIncomingId,\n    incomingWindow: this.session._sessionParams.incomingWindow,\n    nextOutgoingId: this.session._sessionParams.nextOutgoingId,\n    outgoingWindow: this.session._sessionParams.outgoingWindow,\n    available: this.available,\n    deliveryCount: this.deliveryCount,\n    drain: false\n  });\n\n  this.session.connection.sendFrame(new frames.FlowFrame(flowOptions));\n};\n\nLink.prototype._sendDetach = function(options) {\n  options = options || {};\n  var detachoptions = u.defaults(options, {\n    handle: this.handle,\n    channel: this.session.channel,\n    closed: true,\n    error: null\n  });\n\n  this.session.connection.sendFrame(new frames.DetachFrame(detachoptions));\n};\n\nLink.prototype._detached = function(frame) {\n  if (frame && frame.error) {\n    this.emit(Link.ErrorReceived, errors.wrapProtocolError(frame.error));\n  }\n\n  this.remote.detach = frame;\n  if (this.remote.handle !== undefined) {\n    delete this.session._linksByRemoteHandle[this.remote.handle];\n    this.remote.handle = undefined;\n  }\n\n  this.emit(Link.Detached, { closed: frame.closed, error: errors.wrapProtocolError(frame.error) });\n  this._resolveAttachPromises(frame.error ? frame.error : 'link closed');\n  this.sm.detached();\n\n  // now check for whether we should reattach\n  var self = this;\n  if (self.shouldReattach()) {\n    process.nextTick(function() { self._attemptReattach(); });\n  }\n};\n\nLink.prototype.shouldReattach = function() {\n  if (this.session && !this.session.mapped) return false;\n  if (!this.session || !this._timeouts) return false;\n  if (!this._timeouts.length && !this.policy.reattach.forever) return false;\n  return true;\n};\n\nLink.prototype._attemptReattach = function() {\n  var self = this;\n  if (!self._timeouts.length) {\n    self._timeouts = u.generateTimeouts(self.policy.reattach);\n  }\n\n  self.sm.reattach();\n  self._reattachTimer = setTimeout(function() {\n    if (self.shouldReattach()) {\n      debug('attempting to reattach: ' + self.id);\n      self.attach();\n    } else {\n      process.nextTick(function() { self._attemptReattach(); });\n    }\n  }, self._timeouts.shift());\n};\n\nmodule.exports = Link;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/sender_link.js":"'use strict';\n\nvar Builder = require('buffer-builder'),\n    Promise = require('bluebird'),\n    util = require('util'),\n    debug = require('debug')('amqp10:link:sender'),\n\n    frames = require('./frames'),\n    errors = require('./errors'),\n    constants = require('./constants'),\n    putils = require('./policies/policy_utilities'),\n    m = require('./types/message'),\n    u = require('./utilities'),\n\n    DeliveryState = require('./types/delivery_state'),\n    Link = require('./link');\n\n/**\n * @class\n * @extends Link\n */\nfunction SenderLink(session, handle, linkPolicy) {\n  SenderLink.super_.call(this, session, handle, linkPolicy);\n\n  this._pendingSends = [];\n  this._unsettledSends = {};\n}\nutil.inherits(SenderLink, Link);\n\n// public API\nSenderLink.prototype.attach = function() {\n  this.initialDeliveryCount = this.policy.attach.initialDeliveryCount;\n  this.deliveryCount = 0;\n\n  // call super method\n  SenderLink.super_.prototype.attach.call(this);\n};\n\nSenderLink.prototype.canSend = function() {\n  if (this.state() !== 'attached') {\n    return false;\n  }\n\n  var sendable = this.linkCredit >= 1 &&\n    (!this.session.policy.enableSessionFlowControl || this.session._sessionParams.remoteIncomingWindow >= 1);\n  debug('canSend(' + this.linkCredit + ',' + this.session._sessionParams.remoteIncomingWindow + ') = ' + sendable);\n  return sendable;\n};\n\n/**\n * Sends the given message, with the given options on this link\n *\n * @inner @memberof SenderLink\n * @param {object|string|array} msg Message to send.  Will be encoded using sender link policy's encoder.\n * @param {object} [options] An object of options to attach to the message including: annotations, properties,\n *                           and application properties\n * @param {string} [options.callback] Determines when the send operation should callback. Possible\n *                                    options are: 'sent', 'settled' and 'none'. For the best performance\n *                                    choose 'none', which is essentially \"send and forget\" and notably will\n *                                    not return a promise.\n * @param {object} [options.messageAnnotations] Annotations for the message, if any.  See AMQP spec for details, and server for specific\n *                                              annotations that might be relevant (e.g. x-opt-partition-key on EventHub).  If node-amqp-encoder'd\n *                                              map is given, it will be translated to appropriate internal types.  Simple maps will be converted\n *                                              to AMQP Fields type as defined in the spec.\n *\n * @return {Promise|null}\n */\nSenderLink.prototype.send = function(msg, options) {\n  options = options || {};\n\n  var noReply = false;\n  if (options.hasOwnProperty('noReply')) {\n    noReply = !!options.noReply;\n    delete options.noReply;\n  }\n\n  if (!!this.policy.defaultSubject) {\n    if (!options.properties) options.properties = {};\n    if (!options.properties.subject)\n      options.properties.subject = this.policy.defaultSubject;\n  }\n\n  var message;\n  var deliveryTag = this.session._deliveryTag++;\n  if (u.isObject(msg) && msg.hasOwnProperty('body')) {\n    message = msg;\n    message.body = this.policy.encoder ? this.policy.encoder(message.body) : message.body;\n    u.merge(message, options);\n  } else {\n    msg = this.policy.encoder ? this.policy.encoder(msg) : msg;\n    if (u.isObject(options)) {\n      options.body = msg;\n      message = options;\n    } else {\n      message = { body: msg };\n    }\n  }\n\n  var self = this,\n      cbPolicy = self.policy.callback;\n\n  if (cbPolicy === putils.SenderCallbackPolicies.None) {\n    var sendMessage = function(err) {\n      if (!!err) throw err;\n      debug('sending: ', msg);\n      return self._sendMessage(message, {\n        deliveryTag: new Buffer(deliveryTag.toString())\n      });\n    };\n\n    if (!this.canSend()) {\n      this._pendingSends.push(sendMessage);\n      return;\n    }\n\n    sendMessage();\n    return;\n  }\n\n  return new Promise(function(resolve, reject) {\n    var sendMessage = function(err) {\n      if (err) {\n        return reject(err);\n      }\n\n      debug('sending: ', msg);\n      var messageId = self._sendMessage(message, {\n        deliveryTag: new Buffer(deliveryTag.toString())\n      });\n\n      if (cbPolicy === putils.SenderCallbackPolicies.OnSettle) {\n        var deferredSender = function(err, state) {\n          if (!!err) return reject(err);\n          resolve(state);\n        };\n        self._unsettledSends[messageId] = deferredSender;\n      } else if (cbPolicy === putils.SenderCallbackPolicies.OnSent) {\n        resolve();\n      } else {\n        reject(new TypeError('Invalid sender callback policy: ' + cbPolicy));\n      }\n    };\n\n    if (!self.canSend()) {\n      self._pendingSends.push(sendMessage);\n      return;\n    }\n\n    // otherwise send the message\n    sendMessage(null);\n  });\n};\n\n// private API\nSenderLink.prototype._sendMessage = function(message, options) {\n  // preconditions\n  if (this.linkCredit <= 0) {\n    throw new errors.OverCapacityError('Cannot send if no link credit.');\n  }\n\n  options = options || {};\n\n  // session bookkeeping\n  var messageId = this.session._sessionParams.nextOutgoingId;\n  this.session._sessionParams.nextOutgoingId++;\n  this.session._sessionParams.remoteIncomingWindow--;\n  this.session._sessionParams.outgoingWindow--;\n\n  if (this.session._sessionParams.remoteIncomingWindow < 0) {\n    if (this.session.policy.enableSessionFlowControl) {\n      throw new errors.OverCapacityError('Cannot send message - over Session window capacity (' + this.session._sessionParams.remoteIncomingWindow + ' window)');\n    } else {\n      this.session._sessionParams.remoteIncomingWindow =\n        this.session._sessionParams.outgoingWindow = 0;\n    }\n  }\n\n  // create frame(s)\n  var transferOptions = u.defaults(options, {\n    channel: this.session.channel,\n    handle: this.handle,\n    deliveryId: messageId,\n    settled: this.policy.attach.sndSettleMode === constants.senderSettleMode.settled,\n  });\n\n  // pre-encode message to determine if multiple frames are required\n  var messageBuilder = new Builder();\n  m.encodeMessage(message, messageBuilder);\n  var messageBuffer = messageBuilder.get();\n\n  // send the frame(s)\n  var frame;\n  var maxFrameSize = this.session.connection.remote.open.maxFrameSize;\n  var frameOverhead = frames.TRANSFER_FRAME_OVERHEAD + options.deliveryTag.length;\n  var idealMessageSize = maxFrameSize - frameOverhead;\n  var approximateFrameSize = messageBuffer.length + frameOverhead;\n  if (approximateFrameSize >= maxFrameSize) {\n    var messageCount = Math.ceil(messageBuffer.length / idealMessageSize);\n    var bufferIdx = 0;\n    for (var i = 0; i < messageCount; ++i) {\n      transferOptions.more = (i !== messageCount - 1) ? true : false;\n      frame = new frames.TransferFrame(transferOptions);\n      frame.payload = messageBuffer.slice(bufferIdx, bufferIdx + idealMessageSize);\n      this.session.connection.sendFrame(frame);\n      bufferIdx += idealMessageSize;\n    }\n  } else {\n    frame = new frames.TransferFrame(transferOptions);\n    frame.payload = messageBuffer;\n    this.session.connection.sendFrame(frame);\n  }\n\n  this.deliveryCount++;\n  this.linkCredit--;\n  return messageId;\n};\n\nSenderLink.prototype._flowReceived = function(frame) {\n  if (frame.handle !== null) {\n    this.available = frame.available; // TODO: ?? I believe we should not be overwriting this\n    this.linkCredit = frame.deliveryCount + frame.linkCredit - this.deliveryCount;\n\n    debug('setting credits (' + this.linkCredit + ',' + this.session._sessionParams.remoteIncomingWindow + ')');\n  }\n\n  this.emit(Link.CreditChange, this);\n  this._dispatchPendingSends(null);\n};\n\nSenderLink.prototype._attachReceived = function(attachFrame) {\n  SenderLink.super_.prototype._attachReceived.call(this, attachFrame);\n\n  this._dispatchPendingSends(null);\n};\n\nSenderLink.prototype._detached = function(frame) {\n  SenderLink.super_.prototype._detached.call(this, frame);\n\n  // has an error occurred?\n  if (frame && frame.error) {\n    this._dispatchPendingSends(frame.error);\n  }\n};\n\nSenderLink.prototype._dispatchPendingSends = function(err) {\n  if (this._pendingSends && this._pendingSends.length !== 0) {\n    while (this._pendingSends.length > 0 && (!!err ? true : this.canSend())) {\n      var sendMessage = this._pendingSends.shift();\n      sendMessage(err);\n    }\n  }\n\n  if (!!err && this._unsettledSends && Object.keys(this._unsettledSends).length) {\n    var self = this;\n    Object.keys(this._unsettledSends).forEach(function(id) {\n      var deferredSender = self._unsettledSends[id];\n      deferredSender(err, null);\n      delete self._unsettledSends[id];\n    });\n\n    this._unsettledSends = {};\n  }\n};\n\nSenderLink.prototype._dispositionReceived = function(details) {\n  if (!details.settled) {\n    return;\n  }\n\n  var err = null;\n  if (details.state instanceof DeliveryState.Rejected) {\n    err = !!details.state.error ?\n      details.state.error : new errors.BaseError('Message was rejected');\n  }\n\n  var first = details.first;\n  var last = details.last || first;\n  for (var messageId = first; messageId <= last; ++messageId) {\n    if (!this._unsettledSends[messageId]) {\n      continue;\n    }\n\n    this._unsettledSends[messageId](err, details.state);\n    delete this._unsettledSends[messageId];\n  }\n};\n\n// @override\nSenderLink.prototype.forceDetach = function() {\n  this._dispatchPendingSends(new errors.ProtocolError('amqp:link:detach-forced', 'detach-forced'));\n  Link.prototype.forceDetach.call(this);\n};\n\nmodule.exports = SenderLink;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/message.js":"'use strict';\nvar DescribedType = require('./described_type'),\n    ForcedType = require('./forced_type'),\n\n    u = require('../utilities'),\n    wrapField = require('./composite_type').wrapField,\n    errors = require('../errors'),\n    codec = require('../codec');\n\nvar sectionByDescriptor = {},\n    sectionByProperty = {};\n\nfunction defineSection(descriptor, definition) {\n  sectionByDescriptor[descriptor.code] = definition;\n  sectionByDescriptor[descriptor.name] = definition;\n}\n\nfunction defineMapSection(definition) {\n  var descriptor = { name: 'amqp:' + definition.name + ':map', code: definition.code };\n  var property = u.camelCase(definition.name);\n  var sectionDefinition = {\n    descriptor: definition.code, source: !!definition.source ? definition.source : 'map',\n    decode: function(message, described) {\n      message[property] = described.value;\n    }\n  };\n\n  defineSection(descriptor, sectionDefinition);\n  sectionByProperty[property] = sectionDefinition;\n}\n\nfunction defineCompositeSection(definition) {\n  var descriptor = { name: 'amqp:' + definition.name + ':list', code: definition.code };\n  var sectionDefinition = {\n    descriptor: definition.code,\n    encode: function(value, buffer) {\n      var _len = definition.fields.length, result = [];\n      for (var i = 0; i < _len; ++i) {\n        var field = definition.fields[i];\n        result[i] = wrapField(field, value[field.name]);\n      }\n\n      return result;\n    },\n    decode: function(message, described) {\n      var _len = definition.fields.length, data = {};\n      for (var i = 0; i < _len; ++i) {\n        var field = definition.fields[i];\n        data[field.name] = described.value[i];\n      }\n\n      message[definition.name] = data;\n    }\n  };\n\n  defineSection(descriptor, sectionDefinition);\n  sectionByProperty[definition.name] = sectionDefinition;\n}\n\nvar isData = function(x) { return x instanceof Buffer; };\ndefineSection({ code: 0x75, name: 'amqp:data:binary' }, {\n  encode: null,\n  decode: function(message, described) {\n    if (!message.hasOwnProperty('body')) message.body = [];\n    else if (!Array.isArray(message.body) || !message.body.every(isData)) {\n      throw new errors.MalformedPayloadError('Attempt to put both Data and non-Data payloads in message body');\n    }\n\n    message.body.push(described.value);\n  }\n});\n\nvar isSequence = function(x) { return Array.isArray(x); };\ndefineSection({ code: 0x76, name: 'amqp:amqp-sequence:list' }, {\n  encode: null,\n  decode: function(message, described) {\n    if (!message.hasOwnProperty('body')) message.body = [];\n    else if (!Array.isArray(message.body) || !message.body.every(isSequence)) {\n      throw new errors.MalformedPayloadError('Attempt to put both AMQPSequence and non-AMQPSequence payloads in message body');\n    }\n\n    message.body.push(described.value);\n  }\n});\n\ndefineSection({ code: 0x77, name: 'amqp:value:*' }, {\n  encode: null,\n  decode: function(message, described) {\n    if (message.body && Array.isArray(message.body)) {\n      throw new errors.MalformedPayloadError('Attempt to provide more than one AMQPValue for message body');\n    }\n\n    message.body = described.value;\n  }\n});\n\ndefineCompositeSection({\n  name: 'header', code: 0x70,\n  fields: [\n    { name: 'durable', type: 'boolean', default: false },\n    { name: 'priority', type: 'ubyte', default: 4 },\n    { name: 'ttl', type: 'milliseconds' },\n    { name: 'firstAcquirer', type: 'boolean', default: false },\n    { name: 'deliveryCount', type: 'uint', default: 0 }\n  ]\n});\n\ndefineCompositeSection({\n  name: 'properties', code: 0x73,\n  fields: [\n    { name: 'messageId', type: '*' },         // @spec type: `*` requires: `message-id` => various values\n    { name: 'userId', type: 'binary' },\n    { name: 'to', type: 'address' },\n    { name: 'subject', type: 'string' },\n    { name: 'replyTo', type: 'address' },\n    { name: 'correlationId', type: '*' },     // @spec type: `*` requires: `message-id` => various values\n    { name: 'contentType', type: 'symbol' },\n    { name: 'contentEncoding', type: 'symbol' },\n    { name: 'absoluteExpiryTime', type: 'timestamp' },\n    { name: 'creationTime', type: 'timestamp' },\n    { name: 'groupId', type: 'string' },\n    { name: 'groupSequence', type: 'sequence-no' },\n    { name: 'replyToGroupId', type: 'string' }\n  ]\n});\n\ndefineMapSection({ name: 'delivery-annotations', code: 0x71, source: 'fields' });\ndefineMapSection({ name: 'message-annotations', code: 0x72, source: 'fields' });\ndefineMapSection({ name: 'application-properties', code: 0x74, source: 'map' });\ndefineMapSection({ name: 'footer', code: 0x78 , source: 'map' });\n\nmodule.exports.decodeMessage = function(buffer) {\n  var message = {};\n  var curIdx = 0;\n  while (curIdx < buffer.length) {\n    var decoded = codec.decode(buffer, curIdx);\n    if (!decoded) {\n      throw new errors.MalformedPayloadError('Unable to decode bytes from message body: ' + buffer.slice(curIdx).toString('hex'));\n    }\n\n    var described = decoded[0];\n    if (!sectionByDescriptor.hasOwnProperty(described.descriptor)) {\n      throw new errors.MalformedPayloadError('Unknown section: ', described);\n    }\n\n    var sectionDefinition = sectionByDescriptor[described.descriptor];\n    curIdx += decoded[1];\n\n    sectionDefinition.decode(message, described);\n  }\n\n  if (Array.isArray(message.body) && message.body.length === 1)\n    message.body = message.body[0];\n  return message;\n};\n\nmodule.exports.encodeMessage = function(message, buffer) {\n  var _keys = Object.keys(sectionByProperty), _len = _keys.length;\n  for (var i = 0; i < _len; ++i) {\n    var property = _keys[i], definition = sectionByProperty[property];\n    if (message.hasOwnProperty(property)) {\n      var section = message[property];\n      if (definition.encode && typeof definition.encode === 'function') {\n        section = definition.encode(section);\n      }\n\n      var value = definition.hasOwnProperty('source') ?\n        new ForcedType(definition.source, section) : section;\n      var described = new DescribedType(definition.descriptor, value);\n      codec.encode(described, buffer);\n    }\n  }\n\n  if (!!message.body || u.isNumber(message.body)) {\n    // @todo:\n    //  Array[Buffer] => multiple Data segments\n    //  Array[Array] => multiple AMQPSequence\n    if (message.body instanceof DescribedType) {\n      var descriptor = message.body.descriptor;\n      if (!u.includes([0x75, 0x76, 0x77], descriptor)) {\n        throw new errors.MalformedPayloadError(\n            'Invalid described type for message body: ', descriptor);\n      }\n      codec.encode(message.body, buffer);\n    } else if (message.body instanceof Buffer) {\n      codec.encode(new DescribedType(0x75, message.body), buffer);  // Data\n    } else if (Array.isArray(message.body)) {\n      codec.encode(new DescribedType(0x76, message.body), buffer);  // AMQPSequence\n    } else {\n      codec.encode(new DescribedType(0x77, message.body), buffer);  // AMQPValue\n    }\n  }\n\n  return buffer;\n};\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/types/delivery_state.js":"'use strict';\nvar defineComposite = require('./composite_type').defineComposite;\nvar DeliveryState = module.exports = {};\n\nDeliveryState.Received = defineComposite({\n  name: 'received', code: 0x23,\n  fields: [\n    { name: 'sectionNumber', type: 'uint', mandatory: true },\n    { name: 'sectionOffset', type: 'ulong', mandatory: true }\n  ]\n});\n\nDeliveryState.Accepted = defineComposite({\n  name: 'accepted', code: 0x24, fields: []\n});\n\nDeliveryState.Rejected = defineComposite({\n  name: 'rejected', code: 0x25,\n  fields: [\n    { name: 'error', type: 'error' }\n  ]\n});\n\nDeliveryState.Released = defineComposite({\n  name: 'released', code: 0x26, fields: []\n});\n\nDeliveryState.Modified = defineComposite({\n  name: 'modified', code: 0x27,\n  fields: [\n    { name: 'deliveryFailed', type: 'boolean' },\n    { name: 'undeliverableHere', type: 'boolean' },\n    { name: 'messageAnnotations', type: 'fields' }\n  ]\n});\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/receiver_link.js":"'use strict';\n\nvar util = require('util'),\n    BufferList = require('bl'),\n    debug = require('debug')('amqp10:link:receiver'),\n\n    constants = require('./constants'),\n    u = require('./utilities'),\n\n    m = require('./types/message'),\n    frames = require('./frames'),\n    DeliveryState = require('./types/delivery_state'),\n    Link = require('./link');\n\n/**\n * @class\n * @extends Link\n * @fires ReceiverLink#message\n */\nfunction ReceiverLink(session, handle, linkPolicy) {\n  ReceiverLink.super_.call(this, session, handle, linkPolicy);\n  // If we're not auto-settling, we should track settles to allow refresh policies to decide when to re-up.\n  this._trackSettles = linkPolicy && linkPolicy.attach && linkPolicy.attach.rcvSettleMode !== constants.receiverSettleMode.autoSettle;\n  this._currentTransferFrame = null;\n  if (this._trackSettles) this.settledMessagesSinceLastCredit = 0;\n}\nutil.inherits(ReceiverLink, Link);\n\n/**\n * Message received event.  Message payload given as argument.\n *\n * @event ReceiverLink#message\n * @param {object} message the received message\n * @param {object} [transferFrame] the transfer frame the message was extracted from\n */\nReceiverLink.MessageReceived = 'message';\n\n/**\n * Credit change event\n *\n * @event ReceiverLink#creditChange\n */\nReceiverLink.CreditChange = 'creditChange';\n\n// public API\n/**\n * Add credits to this link\n *\n * @inner @memberof ReceiverLink\n * @param {number} credits number of credits to add\n * @param {object} [flowOptions] additional options to include in flow frame\n */\nReceiverLink.prototype.addCredits = function(credits, flowOptions) {\n  if (credits > 0 && this._trackSettles) this.settledMessagesSinceLastCredit = 0;\n\n  // increment credits\n  this.linkCredit += credits;\n  this.session._sessionParams.incomingWindow += credits;\n\n  debug('addCredits ('+this.name+'): New values: link('+this.linkCredit+'), session('+this.session._sessionParams.incomingWindow+')');\n\n  // send flow frame\n  this.flow(flowOptions);\n};\n\n/**\n * Settle a message (or array of messages) with an Accepted delivery outcome\n *\n * @inner @memberof ReceiverLink\n * @param {string|array} message message, or array of messages to settle\n */\nReceiverLink.prototype.accept = function(message) {\n  this.settle(message, new DeliveryState.Accepted());\n};\n\n/**\n * Settle a message (or array of messages) with a Rejected delivery outcome\n *\n * @inner @memberof ReceiverLink\n * @param {string|array} message message, or array of messages to settle\n * @param {string} [error] error that caused the message to be rejected\n */\nReceiverLink.prototype.reject = function(message, error) {\n  this.settle(message, new DeliveryState.Rejected({ error: error }));\n};\n\n/**\n * Settle a message (or array of messages) with a Released delivery outcome\n *\n * @inner @memberof ReceiverLink\n * @param {string|array} message message, or array of messages to settle\n */\nReceiverLink.prototype.release = function(message) {\n  this.settle(message, new DeliveryState.Released());\n};\n\n/**\n * Settle a message (or array of messages) with a Modified delivery outcome\n *\n * @inner @memberof ReceiverLink\n * @param {string|array} message message, or array of messages to settle\n * @param {object} [options] options used for a Modified outcome\n * @param {boolean} [options.deliveryFailed] count the transfer as an unsuccessful delivery attempt\n * @param {boolean} [options.undeliverableHere] prevent redelivery\n * @param {object} [options.messageAnnotations] message attributes to combine with existing annotations\n */\nReceiverLink.prototype.modify = function(message, options) {\n  this.settle(message, new DeliveryState.Modified(options));\n};\n\n/**\n * Settle a message (or array of messages) with a given delivery state\n *\n * @inner @memberof ReceiverLink\n * @param {string|array} message message, or array of messages to settle\n * @param {object} [state] outcome of message delivery\n */\nReceiverLink.prototype.settle = function(message, state) {\n  var range = u.dispositionRange(message);\n  if (this._trackSettles) {\n    this.settledMessagesSinceLastCredit += range.last - range.first + 1;\n  }\n\n  this._sendDisposition(u.defaults(range, {\n    settled: true,\n    state: state\n  }));\n\n  this._checkCredit();\n};\n\n// private API\nReceiverLink.prototype._flowReceived = function(flowFrame) {\n  this.drain = flowFrame.drain;\n  this.deliveryCount = Math.min(this.deliveryCount, flowFrame.deliveryCount);\n\n  this.emit(ReceiverLink.CreditChange, this);\n};\n\nReceiverLink.prototype._checkCredit = function(options) {\n  if (this.policy.credit && typeof this.policy.credit === 'function') {\n    this.policy.credit(this, options);\n  }\n};\n\nReceiverLink.prototype._sendDisposition = function(options) {\n  var dispositionOptions = u.defaults(options, {\n    role: constants.linkRole.receiver,\n    channel: this.session.channel,\n    handle: this.handle\n  });\n\n  this.session.connection.sendFrame(\n    new frames.DispositionFrame(dispositionOptions)\n  );\n};\n\nReceiverLink.prototype._messageReceived = function(transferFrame) {\n  if (transferFrame.aborted) {\n    this._currentTransferFrame = null;\n    debug('Message transfer aborted.');\n    return;\n  }\n\n  if (transferFrame.more) {\n    if (this._currentTransferFrame) {\n      // @todo: What do we do if deliveryId/deliveryTag don't match?\n      this._currentTransferFrame.payload.append(transferFrame.payload);\n    } else {\n      this._currentTransferFrame = transferFrame;\n      // Replace with BufferList for more performant appends.\n      this._currentTransferFrame.payload = new BufferList(this._currentTransferFrame.payload);\n    }\n\n    return;\n  }\n\n  var curFrame = transferFrame;\n  if (this._currentTransferFrame) {\n    this._currentTransferFrame.payload.append(transferFrame.payload);\n    curFrame = this._currentTransferFrame;\n    this._currentTransferFrame = null;\n  }\n\n  var message = m.decodeMessage(curFrame.payload);\n  // store deliveryId for later use\n  Object.defineProperty(message, '_deliveryId', { value: curFrame.deliveryId });\n\n  this.linkCredit--;\n  this.deliveryCount++;\n  debug('Rx message ' + transferFrame.deliveryId + ' on ' + this.name + ', ' + this.linkCredit + ' credit, ' + this.session._sessionParams.incomingWindow + ' window left.');\n  // @todo: Bump link credit based on strategy\n\n  // respect settle mode in policy\n  if (this.policy.attach.rcvSettleMode === constants.receiverSettleMode.autoSettle) {\n    this.accept(message);\n  }\n\n  // optionally decode message based on policy\n  message.body = this.policy.decoder ? this.policy.decoder(message.body) : message.body;\n  debug('received from (' + this.name + '): ' + message.body);\n\n  this.emit(ReceiverLink.MessageReceived, message, curFrame);\n};\n\nReceiverLink.prototype._dispositionReceived = function(details) {\n  debug('not yet processing \"receiver\" disposition frames: ', details);\n};\n\nmodule.exports = ReceiverLink;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/streams/receiver_stream.js":"'use strict';\nvar Readable = require('stream').Readable,\n    util = require('util');\n\nfunction ReceiverStream(link, options) {\n  var highWaterMark = link.policy.creditQuantum || 16;\n  Readable.call(this, { objectMode: true, highWaterMark: highWaterMark });\n  this._link = link;\n  this._increasing = false;\n\n  link.on('message', this._processMessage.bind(this));\n  link.on('detached', this._haltProcessing.bind(this));\n  link.on('errorReceived', this._haltProcessing.bind(this));\n  link.on('creditChange', this._creditChange.bind(this));\n}\nutil.inherits(ReceiverStream, Readable);\n\nReceiverStream.prototype._read = function(size) {\n  if (this._link.linkCredit <= 0 && !this._increasing) {\n    return this._link.addCredits(size);\n  }\n};\n\nReceiverStream.prototype._processMessage = function(message) {\n  if (!this.push(message)) {\n    return this._link.flow({ linkCredit: 0 });\n  }\n};\n\nReceiverStream.prototype._haltProcessing = function() {\n  this.push(null);\n};\n\nReceiverStream.prototype._creditChange = function(credits) {\n  this._increasing = false;\n};\n\nmodule.exports = ReceiverStream;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/streams/sender_stream.js":"'use strict';\nvar Promise = require('bluebird'),\n    Writable = require('stream').Writable,\n    util = require('util');\n\nfunction SenderStream(link, options) {\n  Writable.call(this, { objectMode: true });\n\n  options = options || {};\n  this._noReply = options.hasOwnProperty('noReply') ? !!options.noReply : false;\n  this._link = link;\n}\nutil.inherits(SenderStream, Writable);\n\nSenderStream.prototype._write = function(chunk, encoding, callback) {\n  var promise = this._link.send(chunk, { noReply: this._noReply });\n  if (!(promise instanceof Promise)) return callback();\n\n  return promise\n    .then(function() { callback(); })\n    .error(function(err) { callback(err); });\n};\n\nmodule.exports = SenderStream;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/adapters/translate_encoder.js":"'use strict';\nvar Composites = require('../types/amqp_composites'),\n    AMQPArray = Composites.Array,\n    DescribedType = require('../types/described_type'),\n    ForcedType = require('../types/forced_type'),\n    Type = require('../types').Type;\n\nvar KNOWN_TYPES = [\n  'byte', 'short', 'int', 'long', 'ubyte', 'ushort', 'uint', 'ulong',\n  'float', 'double', 'null', 'boolean', 'string', 'symbol', 'list',\n  'map', 'array', 'uuid'\n];\n\nfunction translate(input) {\n  if (!Array.isArray(input)) {  // raw value\n    return input;\n  }\n\n  var typeName = input[0];\n  var value = input.slice(1);\n  if (typeName === 'list') {\n    return Type.list(value.map(translate));\n  } else if (typeName === 'map') {\n    var map = {};\n    for (var i = 0; i < value.length; i += 2) {\n      map[translate(value[i])] = translate(value[i + 1]);\n    }\n\n    return Type.map(map);\n  } else if (typeName === 'array') {\n    var arrayType = value[0];\n    return new AMQPArray(value.slice(1).map(translate), arrayType);\n  } else if (typeName === 'described') {\n    return new DescribedType(translate(value[0]), translate(value[1]));\n  } else if (KNOWN_TYPES.indexOf(typeName) !== -1) {\n    return Type[typeName](value[0]);\n  }\n\n  return new ForcedType(typeName, translate(value));\n}\n\nmodule.exports = translate;\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/event_hub_policy.js":"'use strict';\nmodule.exports = require('./service_bus_policy');\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/service_bus_policy.js":"'use strict';\nvar constants = require('../constants'),\n    Policy = require('./policy');\n\nmodule.exports = new Policy({\n  defaultSubjects: false,\n  senderLink: {\n    attach: {\n      sndSettleMode: constants.senderSettleMode.settled,\n      maxMessageSize: 10000, // Arbitrary choice\n    },\n    encoder: function(body) {\n      if (body instanceof Buffer) return body;\n      var bodyStr = body;\n      if (typeof body !== 'string') {\n        bodyStr = JSON.stringify(body);\n      }\n      return new Buffer(bodyStr, 'utf8');\n    },\n    reattach: {\n      retries: 10,\n      strategy: 'fibonacci', // || 'exponential'\n      forever: true\n    }\n  },\n  receiverLink: {\n    decoder: function(body) {\n      var bodyStr = null;\n      if (body instanceof Buffer) {\n        bodyStr = body.toString();\n      } else if (typeof body === 'string') {\n        bodyStr = body;\n      } else {\n        return body; // No clue.\n      }\n\n      try {\n        return JSON.parse(bodyStr);\n      } catch (e) {\n        return bodyStr;\n      }\n    },\n    reattach: {\n      retries: 10,\n      strategy: 'fibonacci', // || 'exponential'\n      forever: true\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/service_bus_queue_policy.js":"'use strict';\nmodule.exports = require('./service_bus_policy');","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/service_bus_topic_policy.js":"'use strict';\nmodule.exports = require('./service_bus_policy');\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/qpid_java_policy.js":"'use strict';\nvar Policy = require('./policy'),\n    util = require('util');\n\nfunction QpidJavaPolicy() {\n  Policy.call(this, {\n    defaultSubjects: false\n  });\n}\nutil.inherits(QpidJavaPolicy, Policy);\n\nvar _parseAddress = Policy.prototype.parseAddress;\nQpidJavaPolicy.prototype.parseAddress = function(address) {\n  var result = _parseAddress(address);\n\n  // accept vhosts\n  if (result.path !== '/') {\n    var pathParts = result.path.substr(1).split('/');\n    result.vhost = pathParts[0];\n    result.path = '/' + pathParts.slice(1).join('/');\n  }\n\n  return result;\n};\n\nmodule.exports = new QpidJavaPolicy();\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/lib/policies/activemq_policy.js":"'use strict';\nvar Policy = require('./policy');\nmodule.exports = new Policy({\n  defaultSubjects: false\n});\n","/home/travis/build/npmtest/node-npmtest-amqp10/node_modules/amqp10/tools/formatDebugLog.js":"'use strict';\n\nvar fs = require('fs'),\n    Int64 = require('node-int64'),\n    constants = require('../lib/constants');\n\nif (process.argv.length < 3) {\n  console.warn('Usage: node ' + process.argv[1] + ' <debug output file>');\n  process.exit(1);\n}\n\nvar debugOutputFile = process.argv[2];\nvar tryToConvert = true;\n\nvar rxPrefix = 'amqp10:connection Rx:';\nvar txPrefix = 'amqp10:framing sending frame:';\n\nfunction s(cnt) {\n  var r = '';\n  for (var idx = 0; idx < cnt; ++idx) r += ' ';\n  return r;\n}\n\nfunction checkLength(str, l) {\n  if (str.length < l) {\n    console.log('String smaller than expected: ('+str.length+' < '+l+')');\n    return false;\n  }\n  return true;\n}\n\nfunction x(hexstr, consumed, result, indent) {\n  if (hexstr.length === 0) return { consumed: consumed, result: result };\n\n  var prefix = hexstr.substr(0, 2);\n  hexstr = hexstr.substr(2);\n  consumed += 2;\n  if (prefix === '00') {\n    result += s(indent) + prefix + '\\n';\n    var label = x(hexstr, consumed, result, indent + 2);\n    hexstr = hexstr.substr(label.consumed - consumed);\n    result = label.result;\n    consumed = label.consumed;\n    var body = x(hexstr, consumed, result, indent + 2);\n    hexstr = hexstr.substr(body.consumed - consumed);\n    result = body.result;\n    consumed = body.consumed;\n  } else {\n    var len, nent, val, parsedColl;\n    switch (prefix[0]) {\n      case '4':\n        result += s(indent) + prefix + '\\n';\n        break;\n      case '5':\n        val = hexstr.substr(0, 2);\n        consumed += 2;\n        hexstr = hexstr.substr(2);\n        result += s(indent) + prefix + ' ' + val + '\\n';\n        break;\n      case '6':\n        val = hexstr.substr(0, 4);\n        consumed += 4;\n        hexstr = hexstr.substr(4);\n        result += s(indent) + prefix + ' ' + val + '\\n';\n        break;\n      case '7':\n        val = hexstr.substr(0, 8);\n        consumed += 8;\n        hexstr = hexstr.substr(8);\n        result += s(indent) + prefix + ' ' + val + '\\n';\n        break;\n      case '8':\n        val = hexstr.substr(0, 16);\n        consumed += 16;\n        hexstr = hexstr.substr(16);\n        result += s(indent) + prefix + ' ' + val + '\\n';\n        break;\n      case 'a':\n        len = new Buffer(hexstr.substr(0, 2), 'hex').readUInt8(0);\n        consumed += 2;\n        hexstr = hexstr.substr(2);\n        val = hexstr.substr(0, len * 2);\n        consumed += len * 2;\n        hexstr = hexstr.substr(len * 2);\n        if (tryToConvert || prefix[1] === '1' || prefix[1] === '3') val = new Buffer(val, 'hex').toString('utf8');\n        result += s(indent) + prefix + ' ' + len + '\\n' + s(indent + 2) + val + '\\n';\n        break;\n      case 'b':\n        len = new Buffer(hexstr.substr(0, 8), 'hex').readUInt32BE(0);\n        consumed += 8;\n        hexstr = hexstr.substr(8);\n        val = hexstr.substr(0, len * 2);\n        consumed += len * 2;\n        hexstr = hexstr.substr(len * 2);\n        if (tryToConvert || prefix[1] === '1' || prefix[1] === '3') val = new Buffer(val, 'hex').toString('utf8');\n        result += s(indent) + prefix + ' ' + len + '\\n' + s(indent + 2) + val + '\\n';\n        break;\n      case 'c':\n        len = new Buffer(hexstr.substr(0, 2), 'hex').readUInt8(0);\n        consumed += 2;\n        hexstr = hexstr.substr(2);\n        nent = new Buffer(hexstr.substr(0, 2), 'hex').readUInt8(0);\n        consumed += 2;\n        hexstr = hexstr.substr(2);\n        val = hexstr.substr(0, (len - 1) * 2);\n        consumed += (len - 1) * 2;\n        hexstr = hexstr.substr((len - 1) * 2);\n        parsedColl = x(val, 0, '', indent + 2);\n        result += s(indent) + prefix + ' ' + len + ' ' + nent + '\\n' + parsedColl.result;\n        break;\n      case 'd':\n        len = new Buffer(hexstr.substr(0, 8), 'hex').readUInt32BE(0);\n        consumed += 8;\n        hexstr = hexstr.substr(8);\n        nent = new Buffer(hexstr.substr(0, 8), 'hex').readUInt32BE(0);\n        consumed += 8;\n        hexstr = hexstr.substr(8);\n        val = hexstr.substr(0, (len - 1) * 2);\n        consumed += (len - 1) * 2;\n        hexstr = hexstr.substr((len - 1) * 2);\n        parsedColl = x(val, 0, '', indent + 2);\n        result += s(indent) + prefix + ' ' + len + ' ' + nent + '\\n' + parsedColl.result;\n        break;\n      default:\n        console.log('Error: Unexpected prefix ' + prefix);\n        result += s(indent) + prefix + ' unexpected\\n';\n        break;\n    }\n  }\n  return x(hexstr, consumed, result, indent);\n}\n\nfunction parseHex(hexstr) {\n  var amqpstr = constants.amqpVersion.toString('hex');\n  var headerIdx = hexstr.indexOf(amqpstr);\n  var body = hexstr;\n  if (headerIdx === -1) {\n    console.log('Header \"' + amqpstr + '\" not found, assuming partial trace.  If trace is not frame-aligned, results will be incorrect.');\n  } else {\n    body = hexstr.substr(headerIdx + amqpstr.length);\n  }\n\n  // Assume everything from here on out is frames\n  var parsed = '';\n  var error = false;\n  while (!error && body.length > 0) {\n    var lengthstr = body.substr(0, 8);\n    if (checkLength(body, 16)) {\n      body = body.substr(16);\n      var frameLength64 = new Int64(new Buffer('00000000' + lengthstr, 'hex'));\n      var frameLength = frameLength64.valueOf() * 2 - (8*2);\n      if (checkLength(body, frameLength)) {\n        var frame = body.substr(0, frameLength);\n        var parsedFrame = x(frame, 0, '', 2).result;\n        parsed += 'Frame of length ' + frameLength + ':\\n';\n        parsed += parsedFrame;\n        body = body.substr(frameLength);\n      } else error = true;\n    } else error = true;\n  }\n  return parsed;\n}\n\nfs.readFile(debugOutputFile, function (err, data) {\n  var lines = data.toString().split('\\n');\n  var rxHex = '';\n  var txHex = '';\n  for (var idx in lines) {\n    var line = lines[idx].trim();\n    var idxOfPrefix = line.indexOf(rxPrefix);\n    if (idxOfPrefix >= 0) {\n      var curRxHex = line.substr(idxOfPrefix + rxPrefix.length + 1).trim();\n      if (curRxHex.indexOf(' +') !== -1) {\n        curRxHex = curRxHex.substr(0, curRxHex.indexOf(' +'));\n      }\n      rxHex += curRxHex;\n    }\n    idxOfPrefix = line.indexOf(txPrefix);\n    if (idxOfPrefix >= 0) {\n      var rest = line.substr(idxOfPrefix + txPrefix.length + 1).trim();\n      var idxOfHexStart = rest.indexOf('] : ');\n      if (idxOfHexStart >= 0) {\n        var curTxHex = rest.substr(idxOfHexStart + '] : '.length);\n        if (curTxHex.indexOf(' +') !== -1) {\n          curTxHex = curTxHex.substr(0, curTxHex.indexOf(' +'));\n        }\n        txHex += curTxHex;\n      }\n    }\n  }\n  var parsedRxHex = parseHex(rxHex);\n  var parsedTxHex = parseHex(txHex);\n  console.log('============================================');\n  console.log('=============== Received ===================');\n  console.log('============================================\\n');\n  console.log('Hex:');\n  console.log(rxHex);\n  console.log('\\nParsed:');\n  console.log(parsedRxHex);\n  console.log('\\n============================================');\n  console.log('================= Sent =====================');\n  console.log('============================================\\n');\n  console.log('Hex:');\n  console.log(txHex);\n  console.log('\\nParsed:');\n  console.log(parsedTxHex);\n});\n"}